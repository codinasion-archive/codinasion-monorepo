{
  "slug": "add-two-matrices",
  "title": "Add Two Matrices",
  "c": "// C program for addition of two matrices of size n*n\n#include <stdio.h>\n#define MAX 100\n\nint main()\n{\n    int i, j, n;\n    int mat1[MAX][MAX], mat2[MAX][MAX], mat3[MAX][MAX];\n\n    // Input size of n*n matrix\n    scanf(\"%d\", &n);\n\n    // Input Elements for First Matrix\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            scanf(\"%d\", &mat1[i][j]);\n    }\n\n   // Input Elements for Second Matrix\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            scanf(\"%d\", &mat2[i][j]);\n    }\n\n    // Addition\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            mat3[i][j] = mat1[i][j] + mat2[i][j];\n    }\n\n    // Show addition result\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            printf(\"%d \", mat3[i][j]);\n        printf(\"\\n\");\n    }\n\n    return 0;\n}",
  "c-plus-plus": "\n// C++ program for addition of two matrices\n#include <bits/stdc++.h>\nusing namespace std;\n#define n 3\n\n// Function adds mat1[][] and mat2[][], and stores the result in mat3[][]\nvoid add(int mat1[][n], int mat2[][n], int mat3[][n])\n{\n    int i, j;\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            mat3[i][j] = mat1[i][j]+mat2[i][j];\n    }\n}\n\nint main()\n{\n    int mat1[n][n], mat2[n][n], mat3[n][n], i, j ;\n\n    //Input Elements for First Matrix\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cin>>mat1[i][j];\n    }\n\n   //Input Elements for Second Matrix\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cin>>mat2[i][j];\n    }\n\n    //Addition the two given matrices\n    add(mat1, mat2, mat3);\n\n    //Addition result\n    for(i=0; i<n; i++)\n    {\n        for(j=0; j<n; j++)\n            cout<<mat3[i][j]<<\" \";\n        cout<<endl;\n    }\n\n    return 0;\n}",
  "c-sharp": "using System;\npublic class AddMatrix {\n   public static void Main() {\n      int i, j, n;\n      int[, ] arr1 = new int[20, 20];\n      int[, ] arr2 = new int[20, 20];\n      int[, ] arr3 = new int[20, 20];\n\n      n = 3;\n      Console.Write(\"Enter elements in the first matrix:\\n\");\n\t\t\n      for (i = 0; i < n; i++) {\n         for (j = 0; j < n; j++) {\n            arr1[i, j] = Convert.ToInt32(Console.ReadLine());\n         }\n      }\n      Console.Write(\"Enter elements in the second matrix:\\n\");\n\t\t\n      for (i = 0; i < n; i++) {\n         for (j = 0; j < n; j++) {\n            arr2[i, j] = Convert.ToInt32(Console.ReadLine());\n         }\n      }\n      Console.Write(\"\\nFirst matrix is:\\n\");\n\t\t\n      for (i = 0; i < n; i++) {\n         Console.Write(\"\\n\");\n         for (j = 0; j < n; j++)\n            Console.Write(\"{0}\\t\", arr1[i, j]);\n      }\n      Console.Write(\"\\nSecond matrix is:\\n\");\n\t\t\n      for (i = 0; i < n; i++) {\n         Console.Write(\"\\n\");\n         for (j = 0; j < n; j++)\n            Console.Write(\"{0}\\t\", arr2[i, j]);\n      }\n\t\t\n      for (i = 0; i < n; i++)\n         for (j = 0; j < n; j++)\n         arr3[i, j] = arr1[i, j] + arr2[i, j];\n         Console.Write(\"\\nAdding two matrices: \\n\");\n\n         for (i = 0; i < n; i++) {\n         Console.Write(\"\\n\");\n         for (j = 0; j < n; j++)\n         Console.Write(\"{0}\\t\", arr3[i, j]);\n      }\n      Console.Write(\"\\n\\n\");\n   }\n}\n",
  "java": "// Java program for addition of two matrices\n\n//  java util package is imported to use scanner class \nimport java.util.Scanner;\n\n\npublic class AddTwoMatrices {\n\n  public static void main(String[] args) {\n    int size = 4;\n\n    // Declare the object and initialize with predefined standard input object\n\n    Scanner input = new Scanner(System.in);\n\n    // Create matrix A\n    System.out.println(\"Enter the values for matrix A:\");\n    int[][] A = new int[size][size];\n    for (int i = 0; i < size; i++) {\n      for (int j = 0; j < size; j++) {\n        //nextInt method of java scanner class is used \n        A[i][j] = input.nextInt(); \n      }\n    }\n\n\n    //int[][] A = {{1, 1, 1, 1},\n    //   {2, 2, 2, 2},\n    //    {3, 3, 3, 3},\n    //    {4, 4, 4, 4}};\n\n\n    // Print the matrices A\n    System.out.println(\"\\nMatrix A:\");\n    printMatrix(A, size, size);\n\n\n\n    // Create matrix B\n    System.out.println(\"\\nEnter the values for matrix B:\");\n    int[][] B = new int[size][size];\n    for (int i = 0; i < size; i++) {\n      for (int j = 0; j < size; j++) {\n        B[i][j] = input.nextInt();\n      }\n    }\n\n    //int[][] B = {{1, 1, 1, 1},\n    //    {2, 2, 2, 2},\n    //    {3, 3, 3, 3},\n    //    {4, 4, 4, 4}};\n\n\n\n    // Print the matrices B\n    System.out.println(\"\\nMatrix B:\");\n    printMatrix(B, size, size);\n\n    // Add the two matrices\n    int[][] C = add(A, B, size);\n\n    // Print the result\n    System.out.println(\"\\nResultant Matrix:\");\n    printMatrix(C, size, size);\n  }\n\n  // Function to print Matrix\n  static void printMatrix(int[][] M,\n                          int rowSize,\n                          int colSize) {\n    for (int i = 0; i < rowSize; i++) {\n      for (int j = 0; j < colSize; j++)\n        System.out.print(M[i][j] + \" \");\n\n      System.out.println();\n    }\n  }\n\n  // Function to add the two matrices\n  static int[][] add(int[][] A, int[][] B,\n                     int size) {\n    int i, j;\n    int[][] C = new int[size][size];\n\n    for (i = 0; i < size; i++)\n      for (j = 0; j < size; j++)\n        C[i][j] = A[i][j] + B[i][j];\n\n    return C;\n  }\n}\n",
  "javascript": "function addMatrix(matrix1, matrix2) {\n  let rows = matrix1.length;\n  let cols = matrix1[0].length;\n  let result = new Array(rows);\n  for (let i = 0; i < rows; i++) {\n    result[i] = new Array(cols);\n    for (let j = 0; j < cols; j++) {\n      result[i][j] = matrix1[i][j] + matrix2[i][j];\n    }\n  }\n  return result;\n}\n\nlet matrix1 = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\nlet matrix2 = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\nconsole.log(addMatrix(matrix1, matrix2));\n",
  "kotlin": "fun main() {\n    print(\"Enter the two matrices line separated: \\n\")\n    val size = 3\n\n    val a = readMatrix(size)\n    readln()\n    val b = readMatrix(size)\n\n    val c = addMatrices(a, b)\n    println(\"Result of adding the matrices: \\n\")\n    printMatrix(c)\n}\n\n// Takes number of rows and columns and reads the matrix from input\nfun readMatrix(rows : Int): ArrayList<ArrayList<Int>>{\n    val matrix = arrayListOf<ArrayList<Int>>()\n    for(row in 0 until rows){\n        val line = readln().trim().split(' ')\n        matrix.add(ArrayList())\n        for(number in line){\n            matrix[row].add(Integer.valueOf(number))\n        }\n    }\n    return matrix\n}\n\n// prints a matrix\nfun printMatrix(matrix : ArrayList<ArrayList<Int>>){\n    for (row in matrix){\n        for (cell in row){\n            print(\"$cell \")\n        }\n        println()\n    }\n}\n\n// adds two matrices and return the result in a new matrix\nfun addMatrices(a : ArrayList<ArrayList<Int>>, b : ArrayList<ArrayList<Int>>) : ArrayList<ArrayList<Int>>{\n    val c = a.clone() as ArrayList<ArrayList<Int>>\n    for(i in 0 until b.size){\n        for(j in 0 until b.size){\n            c[i][j] += b[i][j]\n        }\n    }\n    return c\n}\n",
  "ruby": "require \"matrix\"\n   \nmatrix1 = Matrix[[1, 2, 3], [4, 5, 6], [7, 8, 9]] \nmatrix2 = Matrix[[1, 2, 3], [4, 5, 6], [7, 8, 9]] \n\nputs  matrix1 + matrix2\n",
  "typescript": "function addTwoMatrices(matrix1: number[][], matrix2: number[][]) {\n  console.log(\"summing..\");\n  const sum: number[][] = [];\n  for (let i = 0; i < matrix1.length; i++) {\n    sum[i] = [];\n    for (let j = 0; j < matrix1[i].length; j++) {\n      sum[i][j] = matrix1[i][j] + matrix2[i][j];\n    }\n  }\n  return sum;\n}\n\nconst arr1 = [\n  [1, 2],\n  [4, 5],\n  [7, 8],\n];\n\nconst arr2 = [\n  [1, 2],\n  [4, 5],\n  [7, 8],\n];\n\nconsole.log(addTwoMatrices(arr1, arr2));\n",
  "description": "\n## Write a program to add two matrices\n\nMatrix addition is the process of adding two matrices by adding the corresponding elements of the two matrices. Two matrices must have an equal number of rows and columns to be added.\n\n```txt\nInput  :\n1 2 3\n4 5 6\n7 8 9\n\n1 2 3\n4 5 6\n7 8 9\n\nOutput :\n2 4 6\n8 10 12\n14 16 18\n```\n\n---\n",
  "trackId": 4544,
  "lastUpdated": "2024-06-16T16:59:29Z",
  "contributors": [
    "harshraj8843",
    "Varshitha-vankadaru",
    "lookwhoshere99",
    "anandfresh",
    "LeventCelik",
    "sushanth-0",
    "omarfawzy1",
    "greyart1",
    "weaam88",
    "vedantpople4",
    "SarthakSanjay",
    "kelubhai",
    "joao-vitor-souza",
    "priya1011",
    "savi001",
    "ShivangiRai1310"
  ],
  "julia": "A = [1 2 3; 4 5 6; 7 8 9]    \nB = [1 2 3; 4 5 6; 7 8 9]    \n  \nprint(A+B)\n",
  "go": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n)\n\nfunc addmatrix(matrix1 [][]int, matrix2 [][]int) [][]int {\n\tresult := make([][]int, len(matrix1))\n\tfor i, a := range matrix1 {\n\t\tfor j, _ := range a {\n\t\t\tresult[i] = append(result[i], matrix1[i][j]+matrix2[i][j])\n\t\t}\n\t}\n\treturn result\n}\n\nfunc makematrix(size int) [][]int {\n\tm := make([][]int, size)\n\tfor i := 0; i < size; i++ {\n\t\tfor j := 0; j < size; j++ {\n\t\t\tm[i] = append(m[i], rand.Intn(10)-rand.Intn(9))\n\t\t}\n\t}\n\treturn m\n}\n\nfunc main() {\n\tvar size int\n\tfmt.Scanf(\"%d\", &size)\n\tm := makematrix(size)\n\tn := makematrix(size)\n\tfmt.Println(m)\n\tfmt.Println(n)\n\tfmt.Println(\"Addition is:\", addmatrix(m, n))\n\n}\n",
  "haskell": "main :: IO ()\nmain = do\n    putStrLn \"Enter the elements of the first 3x3 matrix separated by spaces:\"\n    matrix1 <- readMatrix\n    putStrLn \"Enter the elements of the second 3x3 matrix separated by spaces:\"\n    matrix2 <- readMatrix\n    let resultMatrix = addMatrices matrix1 matrix2\n    putStrLn \"The sum of the matrices is:\"\n    printMatrix resultMatrix\n\nreadMatrix :: IO [[Int]]\nreadMatrix = sequence $ replicate 3 readRow\n\nreadRow :: IO [Int]\nreadRow = map read . words <$> getLine\n\naddMatrices :: [[Int]] -> [[Int]] -> [[Int]]\naddMatrices mat1 mat2 = zipWith (zipWith (+)) mat1 mat2\n\nprintMatrix :: [[Int]] -> IO ()\nprintMatrix = mapM_ (putStrLn . unwords . map show)\n",
  "php": "<?php\n$a1 = array(\n    array(1,2,3),\n    array(4,5,6),\n    array(7,8,9)\n);\n$a2 = array(\n    array(1,2,3),\n    array(4,5,6),\n    array(7,8,9)\n   \n);\n$row = count($a1);\n$col = count($a1[0]);\necho \"First matrix: \\n\";\nfor ($i = 0; $i < $row; $i++) {\n    for ($j = 0; $j < $col; $j++) {\n        echo $a1[$i][$j] . \" \";\n    }\n    echo \"\\n\";\n}\necho \"Second matrix: \\n\";\nfor ($i = 0; $i < $row; $i++) {\n    for ($j = 0; $j < $col; $j++) {\n        echo $a2[$i][$j] . \" \";\n    }\n    echo \"\\n\";\n} \n$sum = array();\nfor ($i = 0; $i < $row; $i++) {\n    for ($j = 0; $j < $col; $j++) {\n        $sum[$i][$j] = $a1[$i][$j] + $a2[$i][$j];\n    }\n}\necho \"Addition of two matrices: \\n\";\nfor ($i = 0; $i < $row; $i++) {\n    for ($j = 0; $j < $col; $j++) {\n        echo $sum[$i][$j] . \" \";\n    }\n    echo \"\\n\";\n}\n?>\n",
  "perl": "print \"Enter elements in matrix A of size 3x3: \\n\";\nfor($row=0; $row<3 ; $row++) \n{\n  for($col=0; $col<3 ; $col++) \n  {\n    $A[$row][$col] = <STDIN>;\n  }\n}\n\nprint \"Enter elements in matrix B of size 3x3: \\n\";\nfor($row=0; $row<3 ; $row++) \n{\n  for($col=0; $col<3 ; $col++) \n  {\n    $B[$row][$col] = <STDIN>;\n  }\n}\n\nfor($row=0; $row<3 ; $row++) \n{\n  for($col=0; $col<3 ; $col++) \n  {\n    $C[$row][$col] = $A[$row][$col] + $B[$row][$col] ;\n  }\n}\n\nprint \"Sum of the Matrices A+B is : \\n\";\nfor($row=0; $row<3 ; $row++) \n{\n  for($col=0; $col<3 ; $col++) \n  {\n    printf(\"%3d\", $C[$row][$col]);\n  }\n  print \"\\n\";\n}\n",
  "python": "def get_matrix_input(rows, cols):\n    \"\"\"Function to get matrix input from the user.\"\"\"\n    matrix = []\n    print(f\"Enter the elements for a {rows}x{cols} matrix:\")\n    for i in range(rows):\n        row = []\n        for j in range(cols):\n            # Prompt for each element in the row\n            value = float(input(f\"Enter element [{i+1}][{j+1}]: \"))\n            row.append(value)\n        matrix.append(row)\n    return matrix\n\n\ndef add_matrices(matrix1, matrix2):\n    \"\"\"Function to add two matrices.\"\"\"\n    return [\n        [matrix1[i][j] + matrix2[i][j] for j in range(len(matrix1[0]))]\n        for i in range(len(matrix1))\n    ]\n\n\ndef print_matrix(matrix):\n    \"\"\"Function to print the matrix.\"\"\"\n    for row in matrix:\n        print(\" \".join(map(str, row)))\n\n\ndef main():\n    rows = int(input(\"Enter the number of rows for the matrices: \"))\n    cols = int(input(\"Enter the number of columns for the matrices: \"))\n\n    print(\"Matrix 1:\")\n    matrix1 = get_matrix_input(rows, cols)\n    print(\"Matrix 2:\")\n    matrix2 = get_matrix_input(rows, cols)\n\n    # Adding the matrices\n    result_matrix = add_matrices(matrix1, matrix2)\n    print(\"Result of adding Matrix 1 and Matrix 2:\")\n    print_matrix(result_matrix)\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "r": "# Define two matrices\nmatrix1 <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 3, ncol = 3)\nmatrix2 <- matrix(c(5, 6, 7, 8, 1, 2), nrow = 3, ncol = 3)\n\n# Function to add matrices\nadd_matrices <- function(m1, m2) {\n    if (nrow(m1) != nrow(m2) || ncol(m1) != ncol(m2)) {\n        stop(\"Matrices must have the same dimensions\")\n    }\n    return(m1 + m2)\n}\n\n# print the result\nresult_matrix <- add_matrices(matrix1, matrix2)\nprint(\"The sum of the two matrices is:\")\nprint(result_matrix)\n",
  "rust": "use std::fmt;\n\n#[derive(Debug, Clone)]\nstruct Matrix {\n    rows: Vec<Vec<i32>>,\n}\n\nimpl fmt::Display for Matrix {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for x in self.rows.iter() {\n            for y in x.iter() {\n                write!(f, \" {} \", y)?;\n            }\n            write!(f, \"\\n\")?;\n        }\n        write!(f, \"\")\n    }\n}\n\nimpl PartialEq for Matrix {\n    fn eq(&self, other: &Self) -> bool {\n        self.rows == other.rows\n    }\n}\n\nimpl Eq for Matrix {}\n\nimpl Matrix {\n\n    fn empty() -> Matrix {\n        Matrix { rows: vec![] }\n    }\n\n    fn check_add_comparable(m1: &Self, m2: &Self) -> bool {\n        if m1.rows.len() != m2.rows.len() { return false; }\n        for (row_index, row) in m1.rows.iter().enumerate() {\n            if row.len() != m2.rows[row_index].len() { return false; }\n        }\n        return true;\n    }\n\n    fn add(m1: &Self, m2: &Self) -> Option<Matrix> {\n        if !Matrix::check_add_comparable(&m1, &m2) {\n            println!(\"Matrices are of inequal size! Aborting...\");\n            return None;\n        }\n        let mut new = Matrix {rows: vec![]};\n        for (row_index, row) in m1.rows.iter().enumerate() {\n            let mut new_row = vec![];\n            for (col_index, col_elm) in row.iter().enumerate() {\n                new_row.push(col_elm + m2.rows[row_index][col_index]);\n            }\n            new.rows.push(new_row);\n        }\n        return Some(new);\n    }\n}\n\nfn main() {\n    let m1 = Matrix { rows: vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]] };\n    let m2 = Matrix { rows: vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]] };\n    let m3 = Matrix::add(&m1, &m2).unwrap_or(Matrix::empty());\n\n    println!(\"Input:\\n{}\\n{}\\nOutput:\\n{}\", m1, m2, m3);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_correct_addition() {\n        let m1 = Matrix { rows: vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]] };\n        let m2 = Matrix { rows: vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]] };\n        let expected = Matrix { rows: vec![vec![2, 4, 6], vec![8, 10, 12], vec![14, 16, 18]] };\n\n        let result = Matrix::add(&m1, &m2).unwrap_or(Matrix::empty());\n\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn test_unequal_cols_size_matrices() {\n        let m1 = Matrix { rows: vec![vec![1, 2], vec![3, 4]] };\n        let m2 = Matrix { rows: vec![vec![5, 6, 7], vec![8, 9, 10]] };\n\n        let result = Matrix::add(&m1, &m2);\n\n        assert!(result.is_none());\n    }\n    \n    #[test]\n    fn test_unequal_rows_size_matrices() {\n        let m1 = Matrix { rows: vec![vec![1, 2], vec![3, 4]] };\n        let m2 = Matrix { rows: vec![vec![5, 6]] };\n\n        let result = Matrix::add(&m1, &m2);\n\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_empty_matrices() {\n        let m1 = Matrix::empty();\n        let m2 = Matrix::empty();\n        let expected = Matrix::empty();\n\n        let result = Matrix::add(&m1, &m2).unwrap();\n\n        assert_eq!(result, expected);\n    }\n\n\n    // You can add more test cases as needed...\n}\n",
  "languages": [
    "c",
    "c-plus-plus",
    "c-sharp",
    "java",
    "javascript",
    "kotlin",
    "ruby",
    "typescript",
    "julia",
    "go",
    "haskell",
    "php",
    "perl",
    "python",
    "r",
    "rust"
  ]
}