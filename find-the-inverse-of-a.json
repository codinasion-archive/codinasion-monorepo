{
  "slug": "find-the-inverse-of-a",
  "title": "Find The Inverse Of A",
  "c": "#include <stdio.h>\n\nint findMinorAndSign(int a[3][3], int row, int col)\n{\n    int detM[4], p = 0;\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            if (i != row && j != col)\n            {\n                detM[p++] = a[i][j];\n            }\n        }\n    }\n\n    int detValue = detM[0] * detM[3] - detM[1] * detM[2];\n\n    if ((row + col) % 2 == 1)\n    {\n        detValue *= -1;\n    }\n\n    return detValue;\n}\n\nvoid printMatrix(float a[3][3])\n{\n    printf(\"[\");\n    for (int i = 0; i < 3; i++)\n    {\n        printf(\"[\");\n        for (int j = 0; j < 3; j++)\n        {\n            printf(\"%f\", a[i][j]);\n            if (j != 2)\n            {\n                printf(\", \");\n            }\n        }\n        printf(\"]\");\n        if (i != 2)\n        {\n            printf(\", \");\n        }\n    }\n\n    printf(\"]\\n\");\n}\n\nvoid coFactorMatrix(int input[3][3], int output[3][3])\n{\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            output[i][j] = findMinorAndSign(input, i, j);\n        }\n    }\n}\n\nvoid transposeMatrix(int input[3][3], int output[3][3])\n{\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            output[j][i] = input[i][j];\n        }\n    }\n}\nint findDeterminantOfMatrixUsingCoFactorMatrix(int input[3][3], int coFactors[3][3])\n{\n    int result = 0;\n    for (int j = 0; j < 3; j++)\n    {\n        result += (input[0][j] * coFactors[0][j]);\n    }\n    return result;\n}\nint main()\n{\n    int input[3][3] = {{4, 5, 1}, {3, 4, 12}, {10, 2, 1}};\n\n    int coFactors[3][3];\n    coFactorMatrix(input, coFactors);\n\n    int adjoints[3][3];\n    transposeMatrix(coFactors, adjoints);\n\n    int determinant = findDeterminantOfMatrixUsingCoFactorMatrix(input, coFactors);\n\n    if (determinant == 0) // if det=0 , inverse does not exist\n    {\n        printf(\"Its is singular matrix ,there is no inverse of it\");\n    }\n    else\n    {\n        float inverseMatrix[3][3];\n\n        for (int i = 0; i < 3; i++)\n        {\n            for (int j = 0; j < 3; j++)\n            {\n                inverseMatrix[i][j] = ((float)adjoints[i][j] / determinant);\n            }\n        }\n\n        printMatrix(inverseMatrix);\n    }\n}",
  "c-plus-plus": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n  int m[3][3];\n\n  cout << \"Enter the elements of the matrix:\" << endl;\n\n  for(int i = 0; i < 3; i++) {\n    for(int j = 0; j < 3; j++) {\n      cin >> m[i][j];\n    }\n  }\n\n  // intialize determinant\n  float d = 0;\n\n  //finding determinant of the matrix\n  for(int i = 0; i < 3; i++) {\n    d = d + (m[0][i] * (m[1][(i+1)%3] * m[2][(i+2)%3] - m[1][(i+2)%3] * m[2][(i+1)%3]));\n  }\n  \n  if(d > 0) {\n    cout << \"Inverse of this matrix is:\" << endl;\n\n    for(int i = 0; i < 3; i++) {\n      for(int j = 0; j < 3; j++) {\n        cout << ((m[(j+1)%3][(i+1)%3] * m[(j+2)%3][(i+2)%3]) - (m[(j+1)%3][(i+2)%3] * m[(j+2)%3][(i+1)%3]))/ d <<\"\\t\"; //finding adjoint and dividing it by determinant\n      }\n      cout << endl;\n    }\n  } else {\n    cout << \"Inverse does not exist for this matrix\" << endl;\n  }\n\n  return 0;\n\n}",
  "c-sharp": "using System;\n\nnamespace MatrixInverse\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[,] matrix = new int[3, 3];\n            Console.WriteLine(\"Enter the elements of the matrix:\");\n\n            // Read matrix elements from user input\n            for (int i = 0; i < 3; i++)\n            {\n                for (int j = 0; j < 3; j++)\n                {\n                    matrix[i, j] = int.Parse(Console.ReadLine());\n                }\n            }\n\n            // Initialize determinant\n            float d = 0;\n\n            // Finding determinant of the matrix\n            for (int i = 0; i < 3; i++)\n            {\n                d = d + (matrix[0, i] * (matrix[1, (i + 1) % 3] * matrix[2, (i + 2) % 3] - matrix[1, (i + 2) % 3] * matrix[2, (i + 1) % 3]));\n            }\n\n            if (d > 0)\n            {\n                Console.WriteLine(\"Inverse of this matrix is:\");\n\n                // Finding adjoint and dividing it by determinant\n                for (int i = 0; i < 3; i++)\n                {\n                    for (int j = 0; j < 3; j++)\n                    {\n                        Console.Write(((matrix[(j + 1) % 3, (i + 1) % 3] * matrix[(j + 2) % 3, (i + 2) % 3]) - (matrix[(j + 1) % 3, (i + 2) % 3] * matrix[(j + 2) % 3, (i + 1) % 3])) / d + \"\\t\");\n                    }\n                    Console.WriteLine();\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"Inverse does not exist for this matrix\");\n            }\n        }\n    }\n}\n",
  "java": "import java.util.*;\n\npublic class FindTheInverseOfA {\n\n    public static double[][] inverse(double[][] matrix) {\n        int n = matrix.length;\n        double[][] inverse = new double[n][n];\n\n        // create the identity matrix\n        for (int i = 0; i < n; i++) {\n            inverse[i][i] = 1;\n        }\n\n        // augment the matrix with the identity matrix\n        double[][] augmentedMatrix = new double[n][2 * n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                augmentedMatrix[i][j] = matrix[i][j];\n            }\n            for (int j = n; j < 2 * n; j++) {\n                augmentedMatrix[i][j] = inverse[i][j - n];\n            }\n        }\n\n        // perform Gaussian elimination\n        for (int i = 0; i < n; i++) {\n            double pivot = augmentedMatrix[i][i];\n            for (int j = i; j < 2 * n; j++) {\n                augmentedMatrix[i][j] /= pivot;\n            }\n            for (int k = 0; k < n; k++) {\n                if (k != i) {\n                    double factor = augmentedMatrix[k][i];\n                    for (int j = i; j < 2 * n; j++) {\n                        augmentedMatrix[k][j] -= factor * augmentedMatrix[i][j];\n                    }\n                }\n            }\n        }\n\n        // extract the inverse from the augmented matrix\n        for (int i = 0; i < n; i++) {\n            for (int j = n; j < 2 * n; j++) {\n                inverse[i][j - n] = augmentedMatrix[i][j];\n            }\n        }\n\n        return inverse;\n    }\n\n    public static void main(String[] args) {\n        double[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};\n        double[][] inverse = inverse(matrix);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                System.out.print(inverse[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n",
  "javascript": "// Functions:\n// returns the minor for every element in matrix\n// and applies cofactor sign to minor\nfunction minorAndSign(matrix, row, column) {\n  const detNums = [];\n  let detNumIdx = 0;\n  for (let i = 0; i < 3; i++) {\n    for (let j = 0; j < 3; j++) {\n      if (i != row && j != column) {\n        detNums[detNumIdx] = matrix[i][j];\n        detNumIdx += 1;\n      }\n    }\n  }\n  // apply cofactor sign\n  if ((row + column) % 2 != 0) {\n    return detNums[1] * detNums[2] - detNums[0] * detNums[3];\n  }\n  return detNums[0] * detNums[3] - detNums[1] * detNums[2];\n}\n\n// print matrix\nfunction printMatrix(matrix) {\n  for (let row = 0; row < 3; row++) {\n    console.log(matrix[row]);\n  }\n}\n\n// Main:\n// No html file, so set matrix values here\nconst matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\n\n// get determinant\nconst det =\n  matrix[0][0] * minorAndSign(matrix, 0, 0) +\n  matrix[0][1] * minorAndSign(matrix, 0, 1) +\n  matrix[0][2] * minorAndSign(matrix, 0, 2);\n\nif (det === 0) {\n  console.log(\"Matrix is not invertible\");\n} else {\n  // For each element:\n  //  get minor with cofactor sign\n  //  divide by determinant\n  //  put on other side of diagonal\n  const invMatrix = [[], [], []];\n\n  for (let i = 0; i < 3; i++) {\n    for (let j = 0; j < 3; j++) {\n      let minor = minorAndSign(matrix, i, j);\n      invMatrix[j][i] = minor / det; // put on other side of diagonal\n    }\n  }\n  printMatrix(invMatrix);\n}\n",
  "ruby": "require 'matrix'\n\ndef matrix_inverse(matrix)\n  a = Matrix[*matrix]\n  \n  # Check if the matrix is square\n  if a.row_size != a.column_size\n    puts \"The matrix is not square and does not have an inverse.\"\n    return\n  end\n  \n  # Check if the matrix is invertible\n  if a.det == 0\n    puts \"The matrix is not invertible.\"\n    return\n  end\n  \n  a_inv = a.inverse\n  \n  # Print the inverse matrix with floating-point numbers\n  a_inv.to_a.each do |row|\n    row.each { |element| print \"#{element.to_f} \" }\n    puts\n  end\nend\n\n# Example input matrix (invertible)\ninput_matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n]\n\n# Find and print the inverse\nmatrix_inverse(input_matrix)\n",
  "scala": "import scala.util.Try\n\nobject MatrixInverse {\n  \n  def inverse(matrix: Array[Array[Double]]): Option[Array[Array[Double]]] = {\n    Try {\n      val determinant = matrixDeterminant(matrix)\n      if (determinant == 0) None\n      else Some(matrixAdjoint(matrix).map(_.map(_ / determinant)))\n    }.toOption.flatten\n  }\n\n  def matrixDeterminant(matrix: Array[Array[Double]]): Double = {\n    val a = matrix(0)(0); val b = matrix(0)(1); val c = matrix(0)(2)\n    val d = matrix(1)(0); val e = matrix(1)(1); val f = matrix(1)(2)\n    val g = matrix(2)(0); val h = matrix(2)(1); val i = matrix(2)(2)\n\n    a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n  }\n\n  def matrixAdjoint(matrix: Array[Array[Double]]): Array[Array[Double]] = {\n    val a = matrix(0)(0); val b = matrix(0)(1); val c = matrix(0)(2)\n    val d = matrix(1)(0); val e = matrix(1)(1); val f = matrix(1)(2)\n    val g = matrix(2)(0); val h = matrix(2)(1); val i = matrix(2)(2)\n\n    val cofactorMatrix = Array(\n      Array((e * i - f * h), -(b * i - c * h), (b * f - c * e)),\n      Array(-(d * i - f * g), (a * i - c * g), -(a * f - c * d)),\n      Array((d * h - e * g), -(a * h - b * g), (a * e - b * d))\n    )\n    \n    transposeMatrix(cofactorMatrix)\n  }\n\n  def transposeMatrix(matrix: Array[Array[Double]]): Array[Array[Double]] = {\n    (for (j <- matrix(0).indices) yield {\n      (for (i <- matrix.indices) yield {\n        matrix(i)(j)\n      }).toArray\n    }).toArray\n  }\n\n  def main(args: Array[String]): Unit = {\n    val matrix = Array(\n      Array(1.0, 2.0, 3.0),\n      Array(4.0, 5.0, 6.0),\n      Array(7.0, 8.0, 9.0)\n    )\n\n    inverse(matrix) match {\n      case Some(invMatrix) =>\n        println(\"Inverse of the matrix:\")\n        invMatrix.foreach(row => println(row.mkString(\" \")))\n      case None =>\n        println(\"The matrix doesn't have an inverse.\")\n    }\n  }\n}\n",
  "swift": "import Foundation\n\nfunc inverse(of matrix: [[Double]]) -> [[Double]]? {\n    let det = matrixDeterminant(matrix)\n    if det == 0 { return nil }\n\n    let adj = matrixAdjoint(matrix)\n    let inv = adj.map { row in row.map { $0 / det } }\n    return inv\n}\n\nfunc matrixDeterminant(_ matrix: [[Double]]) -> Double {\n    let a = matrix[0][0], b = matrix[0][1], c = matrix[0][2]\n    let d = matrix[1][0], e = matrix[1][1], f = matrix[1][2]\n    let g = matrix[2][0], h = matrix[2][1], i = matrix[2][2]\n\n    return a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n}\n\nfunc matrixAdjoint(_ matrix: [[Double]]) -> [[Double]] {\n    let a = matrix[0][0], b = matrix[0][1], c = matrix[0][2]\n    let d = matrix[1][0], e = matrix[1][1], f = matrix[1][2]\n    let g = matrix[2][0], h = matrix[2][1], i = matrix[2][2]\n\n    let cofactorMatrix: [[Double]] = [\n        [e * i - f * h, c * h - b * i, b * f - c * e],\n        [f * g - d * i, a * i - c * g, c * d - a * f],\n        [d * h - e * g, b * g - a * h, a * e - b * d]\n    ]\n\n    return transposeMatrix(cofactorMatrix)\n}\n\nfunc transposeMatrix(_ matrix: [[Double]]) -> [[Double]] {\n    if matrix.isEmpty { return matrix }\n    var transposedMatrix = Array(repeating: Array(repeating: 0.0, count: matrix.count), count: matrix[0].count)\n\n    for (i, row) in matrix.enumerated() {\n        for (j, element) in row.enumerated() {\n            transposedMatrix[j][i] = element\n        }\n    }\n\n    return transposedMatrix\n}\n\n// Example\nlet matrix = [\n    [2.0, -1.0, 0.0],\n    [-1.0, 2.0, -1.0],\n    [0.0, -1.0, 2.0]\n]\n\nif let inverseMatrix = inverse(of: matrix) {\n    print(\"Inverse of the matrix:\")\n    inverseMatrix.forEach { print($0) }\n} else {\n    print(\"The matrix doesn't have an inverse.\")\n}\n",
  "typescript": "// Functions:\n\n// returns the minor for every element in matrix\n// and applies cofactor sign to minor\nfunction minorAndSign(matrix: number[][], row: number, column: number) {\n  const detNums: number[] = [];\n  let detNumIdx = 0;\n  for (let i = 0; i < matrix.length; i++) {\n    for (let j = 0; j < matrix.length; j++) {\n      if (i !== row && j !== column) {\n        detNums[detNumIdx] = matrix[i][j];\n        detNumIdx++;\n      }\n    }\n  }\n  // apply cofactor sign\n  if ((row + column) % 2 !== 0) {\n    return detNums[1] * detNums[2] - detNums[0] * detNums[3];\n  }\n  return detNums[0] * detNums[3] - detNums[1] * detNums[2];\n}\n\n// print matrix\nfunction printMatrix(matrix: number[][]) {\n  for (let row = 0; row < matrix.length; row++) {\n    console.log(matrix[row]);\n  }\n}\n\n// Main:\n\n// No html file, so set matrix values here\nconst matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\n\n// get determinant\nconst det =\n  matrix[0][0] * minorAndSign(matrix, 0, 0) +\n  matrix[0][1] * minorAndSign(matrix, 0, 1) +\n  matrix[0][2] * minorAndSign(matrix, 0, 2);\n\nif (det === 0) {\n  console.log(\"Matrix is not invertible\");\n} else {\n  // For each element:\n  //  get minor with cofactor sign\n  //  divide by determinant\n  //  put on other side of diagonal\n  const invMatrix: number[][] = [[], [], []];\n\n  for (let i = 0; i < 3; i++) {\n    for (let j = 0; j < 3; j++) {\n      const minor = minorAndSign(matrix, i, j);\n      invMatrix[j][i] = minor / det; // put on other side of diagonal\n    }\n  }\n  printMatrix(invMatrix);\n}\n",
  "description": "\n## Write a program to find the inverse of a\n\nThe inverse of a square matrix A is another square matrix B such that the product of A and B is the identity matrix I. The inverse of A is denoted as A<sup>-1</sup>. Should address case where inverse does not exist.\n\n```txt\nInput  :\n1 2 3\n4 5 6\n7 8 9\n\nOutput :\n\"This matrix is not invertible\"\n\n\nInput  :\n1 -2 3\n4 5 2\n3 8 -2\n\nOutput :\n8.666666666666666 -6.666666666666667 6.333333333333333\n-4.666666666666667 3.6666666666666665 -3.3333333333333335\n-5.666666666666667 4.666666666666667 -4.333333333333333\n```\n\n---\n",
  "trackId": 5271,
  "lastUpdated": "2023-12-01T17:16:31Z",
  "contributors": [
    "Shreyash3110",
    "adesh1998",
    "hemu-git-hub",
    "SidMalladi",
    "harshraj8843",
    "imsherlocked",
    "Ariel201711",
    "dsarussi",
    "AdityaNarayanPradhan",
    "JoshuaT35",
    "cacti23",
    "ShadyResurrected",
    "anandfresh"
  ],
  "perl": "use strict;\nuse warnings;\n\nsub matrix_inverse {\n    my ($matrix) = @_;\n\n    my $size = scalar(@$matrix);\n\n    # Check if the matrix is square\n    die \"Matrix must be square for inversion\" if $size != scalar(@{$matrix->[0]});\n\n    # Augment the matrix with an identity matrix\n    my @augmented_matrix;\n    for my $i (0..$size-1) {\n        for my $j (0..$size-1) {\n            $augmented_matrix[$i][$j] = $matrix->[$i][$j];\n            $augmented_matrix[$i][$j+$size] = ($i == $j) ? 1 : 0;\n        }\n    }\n\n    # Perform Gauss-Jordan elimination\n    for my $i (0..$size-1) {\n        my $pivot = $augmented_matrix[$i][$i];\n\n        die \"Matrix is singular, cannot find inverse\" if $pivot == 0;\n\n        for my $j (0..2*$size-1) {\n            $augmented_matrix[$i][$j] /= $pivot;\n        }\n\n        for my $k (0..$size-1) {\n            next if $k == $i;\n            my $factor = $augmented_matrix[$k][$i];\n            for my $j (0..2*$size-1) {\n                $augmented_matrix[$k][$j] -= $factor * $augmented_matrix[$i][$j];\n            }\n        }\n    }\n\n    # Extract the inverse matrix from the augmented matrix\n    my @inverse_matrix;\n    for my $i (0..$size-1) {\n        for my $j ($size..2*$size-1) {\n            push @{$inverse_matrix[$i]}, $augmented_matrix[$i][$j];\n        }\n    }\n\n    return @inverse_matrix;\n}\n\n# Example usage\nmy @matrix = (\n    [4, 2, 7],\n    [1, 5, 3],\n    [8, 6, 9]\n);\n\nmy @inverse_matrix = matrix_inverse(\\@matrix);\n\n# Print the inverse matrix\nfor my $i (0..$#inverse_matrix) {\n    for my $j (0..$#{$inverse_matrix[$i]}) {\n        printf \"%.16f \", $inverse_matrix[$i][$j];\n    }\n    print \"\\n\";\n}\n\n",
  "python": "import numpy as np\n\ninputArray = np.array([[4, 5, 1], [3, 4, 12], [10, 2, 1]])\n\nresultInverse = np.linalg.inv(inputArray)\n\nprint(resultInverse)\n",
  "r": "determinant <- function(matrix) {\n  a <- matrix[1, 1]\n  b <- matrix[1, 2]\n  c <- matrix[1, 3]\n  d <- matrix[2, 1]\n  e <- matrix[2, 2]\n  f <- matrix[2, 3]\n  g <- matrix[3, 1]\n  h <- matrix[3, 2]\n  i <- matrix[3, 3]\n\n  det <- a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n  return(det)\n}\nmatrixInverse <- function(matrix) {\n  det <- determinant(matrix)\n\n  if (det == 0) {\n    stop(\"The matrix is singular, it does not have an inverse.\")\n  }\n\n  inverse <- matrix(0, nrow = 3, ncol = 3)\n\n  inverse[1, 1] <- (matrix[2, 2] * matrix[3, 3] - matrix[2, 3] * matrix[3, 2]) / det\n  inverse[1, 2] <- (matrix[1, 3] * matrix[3, 2] - matrix[1, 2] * matrix[3, 3]) / det\n  inverse[1, 3] <- (matrix[1, 2] * matrix[2, 3] - matrix[1, 3] * matrix[2, 2]) / det\n  inverse[2, 1] <- (matrix[2, 3] * matrix[3, 1] - matrix[2, 1] * matrix[3, 3]) / det\n  inverse[2, 2] <- (matrix[1, 1] * matrix[3, 3] - matrix[1, 3] * matrix[3, 1]) / det\n  inverse[2, 3] <- (matrix[1, 3] * matrix[2, 1] - matrix[1, 1] * matrix[2, 3]) / det\n  inverse[3, 1] <- (matrix[2, 1] * matrix[3, 2] - matrix[2, 2] * matrix[3, 1]) / det\n  inverse[3, 2] <- (matrix[1, 2] * matrix[3, 1] - matrix[1, 1] * matrix[3, 2]) / det\n  inverse[3, 3] <- (matrix[1, 1] * matrix[2, 2] - matrix[1, 2] * matrix[2, 1]) / det\n\n  return(inverse)\n}\n\ninput_matrix <- matrix(c(4, 5, 1, 3, 4, 12, 10, 2, 1), nrow = 3, byrow = TRUE)\ninverse_matrix <- matrixInverse(input_matrix)\nprint(inverse_matrix)",
  "rust": "fn inverse(matrix: &Vec<Vec<f64>>) -> Option<Vec<Vec<f64>>> {\n    let det = matrix_determinant(matrix);\n    if det == 0.0 {\n        return None;\n    }\n\n    let adj = matrix_adjoint(matrix);\n    let inv: Vec<Vec<f64>> = adj\n        .iter()\n        .map(|row| row.iter().map(|&x| x / det).collect())\n        .collect();\n\n    Some(inv)\n}\n\nfn matrix_determinant(matrix: &Vec<Vec<f64>>) -> f64 {\n    let a = matrix[0][0];\n    let b = matrix[0][1];\n    let c = matrix[0][2];\n    let d = matrix[1][0];\n    let e = matrix[1][1];\n    let f = matrix[1][2];\n    let g = matrix[2][0];\n    let h = matrix[2][1];\n    let i = matrix[2][2];\n\n    a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n}\n\nfn matrix_adjoint(matrix: &Vec<Vec<f64>>) -> Vec<Vec<f64>> {\n    let a = matrix[0][0];\n    let b = matrix[0][1];\n    let c = matrix[0][2];\n    let d = matrix[1][0];\n    let e = matrix[1][1];\n    let f = matrix[1][2];\n    let g = matrix[2][0];\n    let h = matrix[2][1];\n    let i = matrix[2][2];\n\n    let cofactor_matrix: Vec<Vec<f64>> = vec![\n        vec![e * i - f * h, c * h - b * i, b * f - c * e],\n        vec![f * g - d * i, a * i - c * g, c * d - a * f],\n        vec![d * h - e * g, b * g - a * h, a * e - b * d],\n    ];\n\n    transpose_matrix(&cofactor_matrix)\n}\n\nfn transpose_matrix(matrix: &Vec<Vec<f64>>) -> Vec<Vec<f64>> {\n    if matrix.is_empty() {\n        return matrix.clone();\n    }\n\n    let mut transposed_matrix = vec![vec![0.0; matrix.len()]; matrix[0].len()];\n\n    for (i, row) in matrix.iter().enumerate() {\n        for (j, &element) in row.iter().enumerate() {\n            transposed_matrix[j][i] = element;\n        }\n    }\n\n    transposed_matrix\n}\n\nfn main() {\n    let matrix: Vec<Vec<f64>> = vec![\n        vec![2.0, -1.0, 0.0],\n        vec![-1.0, 2.0, -1.0],\n        vec![0.0, -1.0, 2.0],\n    ];\n\n    if let Some(inverse_matrix) = inverse(&matrix) {\n        println!(\"Inverse of the matrix:\");\n        for row in inverse_matrix.iter() {\n            println!(\"{:?}\", row);\n        }\n    } else {\n        println!(\"The matrix doesn't have an inverse.\");\n    }\n}\n",
  "languages": [
    "c",
    "c-plus-plus",
    "c-sharp",
    "java",
    "javascript",
    "ruby",
    "scala",
    "swift",
    "typescript",
    "perl",
    "python",
    "r",
    "rust"
  ]
}