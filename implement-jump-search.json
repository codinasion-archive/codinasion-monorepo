{
  "slug": "implement-jump-search",
  "title": "Implement Jump Search",
  "c": "#include <stdio.h>\n#include <math.h>\n\nint jumpSearch(int arr[], int n, int x) {\n    int blockSize = sqrt(n);\n    int prev = 0;\n\n    while (arr[(int)(fmin(blockSize, n) -1 )] < x) {\n        prev = blockSize;\n        blockSize += sqrt(n);\n        if (prev >= n)\n            return -1; \n    }\n\n    while (arr[prev] < x) {\n        prev++;\n\n        if (prev == fmin(blockSize, n))\n            return -1; \n    }\n\n    if (arr[prev] == x)\n        return prev; \n\n    return -1; \n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    int x = 5;\n    int result = jumpSearch(arr, n, x);\n\n    if (result != -1)\n        printf(\"Output: %d\\n\", result);\n    else\n        printf(\"Value not found in the list\\n\");\n\n    return 0;\n}\n",
  "c-plus-plus": "#include <iostream>\n#include <vector>\n#include <cmath>\n\n// Jump Search function\nint jumpSearch(std::vector<int>& arr, int target) {\n    int n = arr.size();\n    int step = sqrt(n); // Jump step size\n\n    int prev = 0;\n    while (arr[std::min(step, n) - 1] < target) {\n        prev = step;\n        step += sqrt(n);\n        if (prev >= n)\n            return -1; // Element not found\n    }\n\n    while (arr[prev] < target) {\n        prev++;\n        if (prev == std::min(step, n))\n            return -1; // Element not found\n    }\n\n    if (arr[prev] == target)\n        return prev;\n\n    return -1; // Element not found\n}\n\nint main() {\n    std::vector<int> arr;\n    int n, target;\n\n    std::cout << \"Enter the number of elements in the array: \";\n    std::cin >> n;\n\n    std::cout << \"Enter \" << n << \" sorted elements:\" << std::endl;\n    for (int i = 0; i < n; i++) {\n        int num;\n        std::cin >> num;\n        arr.push_back(num);\n    }\n\n    std::cout << \"Enter the element you want to search for: \";\n    std::cin >> target;\n\n    int index = jumpSearch(arr, target);\n\n    if (index != -1) {\n        std::cout << \"Element \" << target << \" found at index \" << index << std::endl;\n    } else {\n        std::cout << \"Element \" << target << \" not found in the array.\" << std::endl;\n    }\n\n    return 0;\n}\n",
  "c-sharp": "using System;\n\nclass JumpSearch\n{\n    public static int JumpSearchFunction(int[] arr, int target)\n    {\n        int n = arr.Length;\n        int step = (int)Math.Floor(Math.Sqrt(n));\n        int prev = 0;\n\n        while (arr[Math.Min(step, n) - 1] < target)\n        {\n            prev = step;\n            step += (int)Math.Floor(Math.Sqrt(n));\n            if (prev >= n)\n                return -1;\n        }\n\n        while (arr[prev] < target)\n        {\n            prev++;\n\n            if (prev == Math.Min(step, n))\n                return -1;\n        }\n\n        if (arr[prev] == target)\n            return prev;\n\n        return -1;\n    }\n\n    public static void Main(string[] args)\n    {\n        Console.WriteLine(\"Enter the number of elements in the array:\");\n        int n = int.Parse(Console.ReadLine());\n        int[] arr = new int[n];\n\n        Console.WriteLine(\"Enter the elements of the array in sorted order and enter to input next number:\");\n        for (int i = 0; i < n; i++)\n        {\n            arr[i] = int.Parse(Console.ReadLine());\n        }\n\n        Console.WriteLine(\"Enter the element to search:\");\n        int target = int.Parse(Console.ReadLine());\n\n        int result = JumpSearchFunction(arr, target);\n\n        if (result == -1)\n        {\n            Console.WriteLine(\"Element not found in the array.\");\n        }\n        else\n        {\n            Console.WriteLine($\"Element found at index {result}.\");\n        }\n    }\n}\n",
  "java": "import java.util.*;\n\npublic class ImplementJumpSearch {\n\n    public static int implementJumpSearch(int[] arr, int x ){\n\n        //calculating the block size to be jumped\n        double blockSize = Math.floor(Math.sqrt(arr.length));\n        int prev = 0;\n\n        // Finding the block where element could be present\n        while (arr[(int) (Math.min(blockSize, arr.length) - 1)] < x) {\n            prev = (int)blockSize;\n            blockSize += Math.floor(Math.sqrt(arr.length));\n\n            if (prev >= arr.length) {\n                return -1; // Element Not present\n            }\n        }\n\n        // Linear search within the block\n        while (arr[prev] < x) {\n            prev++;\n\n            if (prev ==Math.min(blockSize, arr.length)) {\n                return -1; // Element Not present\n            }\n        }\n\n        // If the element is present\n        if (arr[prev] == x) {\n            return prev;\n        }\n\n        return -1;\n    }\n\n\n    public static void main(String[] args){\n\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.println(\"Enter the size of the array:\");\n        int size = scanner.nextInt();\n\n        int[] inputArray = new int[size];\n\n        System.out.println(\"Enter the elements of the array:\");\n        for(int i=0;i<size;i++){\n            inputArray[i] = scanner.nextInt();\n        }\n\n        Arrays.sort(inputArray);\n\n        System.out.println(\"Enter the value to search:\");\n\n        int searchValue = scanner.nextInt();\n\n        int result = ImplementJumpSearch.implementJumpSearch(inputArray,searchValue);\n        if(result==-1){\n            System.out.println(\"value not present\");\n        }\n        else{\n            System.out.println(\"Element found at index: \"+result);\n        }\n        scanner.close();\n\n    }\n}\n",
  "javascript": "function jumpSearch(arr, a) {\n    const n = arr.length;\n    let blockSize = Math.floor(Math.sqrt(n));\n    let prev = 0;\n\n    while (arr[Math.min(blockSize, n) - 1] < a) {\n        prev = blockSize;\n        blockSize += Math.floor(Math.sqrt(n));\n\n        if (prev >= n) {\n            return -1; \n        }\n    }\n\n    while (arr[prev] < a) {\n        prev++;\n        if (prev === Math.min(blockSize, n)) {\n            return -1;\n        }\n    }\n\n    if (arr[prev] === a) {\n        return prev;\n    }\n\n    return -1;\n}\n\nconst input = [1, 2, 3, 4, 5];\nconst search = 4;\nconst res = jumpSearch(input, search);\n\nif (res !== -1) {\n    console.log(`Element ${search} found at index ${res}`);\n} else {\n    console.log(`Element ${search} not found`);\n}\n",
  "kotlin": "import kotlin.math.sqrt\n\nfun jumpSearch(arr: IntArray, x: Int): Int? {\n    val n = arr.size\n    var blockSize = sqrt(n.toDouble()).toInt()\n    var prev = 0\n    \n    while (arr[minOf(blockSize, n) - 1] < x) {\n        prev = blockSize\n        blockSize += sqrt(n.toDouble()).toInt()\n        if (prev >= n) {\n            return null\n        }\n    }\n    \n    while (arr[prev] < x) {\n        prev++\n        if (prev == minOf(blockSize, n)) {\n            return null\n        }\n    }\n    \n    if (arr[prev] == x) {\n        return prev\n    }\n    \n    return null\n}\n\nfun main() {\n    // Take input from the user\n    println(\"Enter the sorted array elements separated by spaces:\")\n    val inputArray = readLine()?.split(\" \")?.map { it.toInt() }\n    if (inputArray != null) {\n        val list = inputArray.toIntArray()\n\n        println(\"Enter the value to search:\")\n        val value = readLine()?.toInt()\n\n        if (value != null) {\n            val index = jumpSearch(list, value)\n            if (index != null) {\n                println(\"Output: $index\")\n            } else {\n                println(\"Output: not found\")\n            }\n        } else {\n            println(\"Invalid input for the value.\")\n        }\n    } else {\n        println(\"Invalid input for the array.\")\n    }\n}\n",
  "ruby": "def jump_search(arr, x)\n  n = arr.size\n  block_size = Math.sqrt(n).to_i\n\n  prev = 0\n  while arr[[block_size, n].min - 1] < x\n    prev = block_size\n    block_size += Math.sqrt(n).to_i\n    return -1 if prev >= n\n  end\n\n  while arr[prev] < x\n    prev += 1\n    return -1 if prev == [block_size, n].min\n  end\n\n  return prev if arr[prev] == x\n\n  -1\nend\n\n# Example usage\narr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nx = 7\nresult = jump_search(arr, x)\n\nif result != -1\n  puts \"Element found at index #{result}\"\nelse\n  puts \"Element not found in the array\"\nend\n",
  "scala": "object JumpSearch {\n\n  def jumpSearch(arr: Array[Int], x: Int): Int = {\n    val n = arr.length\n    val jump = Math.sqrt(n.toDouble).toInt // Calculate optimal jump size\n\n    var prev = 0\n\n    // Find the block where x should be present\n    while (arr(Math.min(n - 1, prev)) < x) {\n      prev += jump\n    }\n\n    // Do a linear search in the current block\n    var curr = Math.max(0, prev - jump)\n    while (curr < Math.min(n, prev)) {\n      if (arr(curr) == x) {\n        return curr\n      }\n      curr += 1\n    }\n\n    // Not found\n    return -1\n  }\n\n  def main(args: Array[String]): Unit = {\n    val list = Array(1, 2, 3, 4, 5)\n    val value = 4\n    val index = jumpSearch(list, value)\n\n    if (index != -1) {\n      println(s\"Element $value found at index: $index\")\n    } else {\n      println(s\"Element $value not found in the list\")\n    }\n  }\n}\n",
  "swift": "\nimport Foundation\n\nfunc jumpSearch(_ arr: [Int], _ x: Int) -> Int? {\n    let n = arr.count\n    var blockSize = Int(sqrt(Double(n))) // Changed to var\n    var prev = 0\n    \n    while arr[min(blockSize, n) - 1] < x {\n        prev = blockSize\n        blockSize += Int(sqrt(Double(n)))\n        if prev >= n {\n            return nil\n        }\n    }\n    \n    while arr[prev] < x {\n        prev += 1\n        if prev == min(blockSize, n) {\n            return nil\n        }\n    }\n    \n    if arr[prev] == x {\n        return prev\n    }\n    \n    return nil\n}\n\n// Take input from the user\nprint(\"Enter the sorted array elements separated by spaces:\")\nif let input = readLine() {\n    let list = input.split(separator: \" \").compactMap { Int($0) } // Corrected\n    print(\"Enter the value to search:\")\n    if let valueInput = readLine(), let value = Int(valueInput) {\n        if let index = jumpSearch(list, value) {\n            print(\"Output:\", index)\n        } else {\n            print(\"Output: not found\")\n        }\n    } else {\n        print(\"Invalid input for the value.\")\n    }\n} else {\n    print(\"Invalid input for the array.\")\n}\n",
  "typescript": "function jumpSearch(arr: number[], x: number): number {\n    const n = arr.length;\n    let blockSize = Math.floor(Math.sqrt(n));\n    let prev = 0;\n\n    // Jumping to the right block\n    while (arr[Math.min(blockSize, n) - 1] < x) {\n        prev = blockSize;\n        blockSize += Math.floor(Math.sqrt(n));\n\n        if (prev >= n) {\n            return -1; // Not found\n        }\n    }\n\n    // Linear search within the block\n    while (arr[prev] < x) {\n        prev++;\n\n        if (prev === Math.min(blockSize, n)) {\n            return -1; // Not found\n        }\n    }\n\n    // If the element is found\n    if (arr[prev] === x) {\n        return prev;\n    }\n\n    return -1; // Not found\n}\n\n// Example usage\nconst exampleInput = [1, 2, 3, 4, 5];\nconst valueToSearch = 4;\nconst res = jumpSearch(exampleInput, valueToSearch);\n\nif (res !== -1) {\n    console.log(`Element ${valueToSearch} found at index ${res}`);\n} else {\n    console.log(`Element ${valueToSearch} not found`);\n}\n",
  "description": "\n## Write a program to implement jump search\n\nLike Binary Search, Jump Search is a searching algorithm for sorted arrays. The basic idea is to check fewer elements (than linear search) by jumping ahead by fixed steps or skipping some elements in place of searching all elements.\r\n\r\nFor example, suppose we have an array arr[] of size n and block (to be jumped) size m. Then we search at the indexes arr[0], arr[m], arr[2m]…..arr[km] and so on. Once we find the interval (arr[km] < x < arr[(k+1)m]), we perform a linear search operation from the index km to find the element x.\r\n\r\n### Pseudocode\r\n\r\n```text\r\nprocedure jump_search\r\n   A ← sorted array\r\n   n ← size of array\r\n   x ← value to be searched\r\n\r\n   Set block size = √n\r\n\r\n   while A[min(block size, n)-1] < x do\r\n      prev = block size\r\n      block size = block size + √n\r\n      if prev >= n\r\n         return not found\r\n         \r\n   end while\r\n   \r\n   while A[prev] < x do\r\n      prev = prev + 1\r\n      \r\n      if prev == min(block size, n)\r\n         return not found\r\n         \r\n   end while\r\n   \r\n   if A[prev] == x\r\n      return prev\r\n      \r\n   return not found\r\nend procedure\r\n```\r\n\r\n### Example\r\n\r\n```text\r\nlist = [1,2,3,4,5]\r\nvalue = 4\r\n\r\nOutput : 3\r\n```\n\n---\n",
  "trackId": 5253,
  "lastUpdated": "2024-07-04T18:29:06Z",
  "contributors": [
    "Riyazul555",
    "harshraj8843",
    "pramod-karkhani",
    "pojith",
    "lingalaviran",
    "bharathbarma94",
    "Shivamk034",
    "chintanrupareliya",
    "PunugupatiSaikumar",
    "srivamsidandu",
    "anandfresh",
    "anurag1807-atom",
    "av-techspot"
  ],
  "julia": "function jump_search(arr::Vector{T}, x::T) where T\n    n = length(arr)\n    step = floor(Int, sqrt(n))\n    prev = 0\n    \n    # Finding the block where element is present\n    while arr[min(step, n)-1] < x\n        prev = step\n        step += floor(Int, sqrt(n))\n        if prev >= n\n            return -1  # Element not found\n        end\n    end\n    \n    # Linear search for x in block beginning with prev\n    while arr[prev] < x\n        prev += 1\n        \n        # If we reached the next block or end of array, element is not present.\n        if prev == min(step, n)\n            return -1  # Element not found\n        end\n    end\n    \n    # If element is found\n    if arr[prev] == x\n        return prev\n    end\n    \n    return -1  # Element not found\nend\n\n# Example usage\narr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nx = 7\n\nresult = jump_search(arr, x)\nif result != -1\n    println(\"Element $x is at index $result\")\nelse\n    println(\"Element $x is not present in the array\")\nend\n",
  "dart": "import 'dart:math';\n\nint jumpSearch(List<int> array, int x) {\n  int n = array.length;\n  int blockSize = sqrt(n).toInt();\n  int prev = 0;\n\n  // Jump to the right block\n  while (array[min(blockSize, n) - 1] < x) {\n    prev = blockSize;\n    blockSize += sqrt(n).toInt();\n    if (prev >= n) {\n      return -1; // Element not found\n    }\n  }\n\n  // Linear search within the block\n  while (array[prev] < x) {\n    prev++;\n    if (prev == min(blockSize, n)) {\n      return -1; // Element not found\n    }\n  }\n\n  if (array[prev] == x) {\n    return prev; // Element found at index prev\n  }\n\n  return -1; // Element not found\n}\n\nvoid main() {\n  List<int> list = [1, 2, 3, 4, 5];\n  int value = 4;\n\n  int result = jumpSearch(list, value);\n\n  if (result != -1) {\n    print('Element $value found at index $result');\n  } else {\n    print('Element $value not found in the list');\n  }\n}",
  "go": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc jumpSearch(arr []int, n int, x int) int {\n\tblockSize := int(math.Sqrt(float64(n)))\n\tprev := 0\n\n\tfor arr[min(blockSize-1, n-1)] < x {\n\t\tprev = blockSize\n\t\tblockSize += int(math.Sqrt(float64(n)))\n\t\tif prev >= n {\n\t\t\treturn -1\n\t\t}\n\t}\n\n\tfor arr[prev] < x && prev < min(blockSize, n) {\n\t\tprev++\n\t}\n\n\tif arr[prev] == x {\n\t\treturn prev\n\t}\n\n\treturn -1\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc main() {\n\tarr := []int{1, 2, 3, 4, 5}\n\tx := 5\n\n\tindex := jumpSearch(arr, len(arr), x)\n\n\tif index != -1 {\n\t\tfmt.Println(\"Value found at index:\", index)\n\t} else {\n\t\tfmt.Println(\"Value not found in the list\")\n\t}\n}\n",
  "haskell": "import Data.List\n\n-- Jump search function\njumpSearch :: (Ord a) => [a] -> a -> Maybe Int\njumpSearch arr x\n    | null arr = Nothing\n    | otherwise =\n        let n = length arr\n            blockSize = floor (sqrt (fromIntegral n))\n            recJumpSearch prev blockSize\n                | prev >= n = Nothing\n                | arr !! prev < x =\n                    recJumpSearch (min (prev + blockSize) (n - 1)) blockSize\n                | arr !! prev == x = Just prev\n                | otherwise =\n                    let recLinearSearch idx\n                            | idx >= min (prev + blockSize) (n - 1) = Nothing\n                            | arr !! idx == x = Just idx\n                            | otherwise = recLinearSearch (idx + 1)\n                    in recLinearSearch prev\n        in recJumpSearch 0 blockSize\n\n-- Function to read a list of integers from the user\nreadIntList :: IO [Int]\nreadIntList = do\n    putStrLn \"Enter a list of integers separated by spaces:\"\n    input <- getLine\n    let parsedInput = map read $ words input :: [Int]\n    return parsedInput\n\nmain :: IO ()\nmain = do\n    -- Read the list of integers from the user\n    arr <- readIntList\n\n    -- Sort the list\n    let sortedArr = sort arr\n\n    -- Read the value to be searched from the user\n    putStrLn \"Enter the value to search for:\"\n    value <- readLn :: IO Int\n\n    -- Perform jump search and print the result\n    case jumpSearch sortedArr value of\n        Just idx -> putStrLn $ \"Value found at index: \" ++ show idx\n        Nothing -> putStrLn \"Value not found in the list.\"\n",
  "php": "<?php\nfunction jumpSearch($arr, $x) {\n    $n = count($arr);\n    $blockSize = (int) sqrt($n);\n    $prev = 0;\n\n    while ($arr[min($blockSize, $n) - 1] < $x) {\n        $prev = $blockSize;\n        $blockSize += (int) sqrt($n);\n        if ($prev >= $n) {\n            return -1; // Element not found\n        }\n    }\n\n    while ($arr[$prev] < $x) {\n        $prev++;\n        if ($prev == min($blockSize, $n)) {\n            return -1;\n        }\n    }\n\n    if ($arr[$prev] == $x) {\n        return $prev;\n    }\n\n    return -1;\n}\n\necho \"Enter array elements separated by space: \";\n$input = trim(fgets(STDIN));\n$inputArray = explode(\" \", $input);\n$inputArray = array_map('intval', $inputArray);\n\necho \"Enter the value to search for: \";\n$searchValue = intval(trim(fgets(STDIN)));\n\n$result = jumpSearch($inputArray, $searchValue);\n\nif ($result == -1) {\n    echo \"Element not found in the array\\n\";\n} else {\n    echo \"Element found at index \" . $result . \"\\n\";\n}\n?>\n",
  "perl": "use strict;\nuse warnings;\n\nsub jump_search {\n    my ($arr_ref, $x) = @_;\n\n    my $n = scalar(@$arr_ref);\n    my $block_size = int(sqrt($n));\n    my $prev = 0;\n\n    # Finding the block where the element may present\n    while ($arr_ref->[$block_size - 1] < $x) {\n        $prev = $block_size;\n        $block_size += int(sqrt($n));\n        return -1 if $prev >= $n; # Not found\n    }\n\n    # Doing linear search in the identified block\n    while ($arr_ref->[$prev] < $x) {\n        $prev++;\n        return -1 if $prev == min($block_size, $n); # Not found\n    }\n\n    # If element is found\n    return $prev if $arr_ref->[$prev] == $x;\n    \n    return -1; # Not found\n}\n\n# Helper function to get the minimum of two numbers\nsub min {\n    my ($a, $b) = @_;\n    return $a < $b ? $a : $b;\n}\n\n# Example usage\nmy @arr = (1, 3, 5, 7, 9, 11, 13, 15, 17, 19);\nmy $x = 13;\nmy $index = jump_search(\\@arr, $x);\n\nif ($index != -1) {\n    print \"Element $x found at index $index.\\n\";\n} else {\n    print \"Element $x not found in the array.\\n\";\n}\n",
  "python": "import math\n\n\ndef jump_search(arr, x, n):\n    block_size = math.sqrt(n)\n\n    while arr[int(min(block_size, n) - 1)] < x:\n        prev = block_size\n        block_size += math.sqrt(n)\n        if prev >= n:\n            return -1\n\n    while arr[int(prev)] < x:\n        prev += 1\n\n        if prev == min(block_size, n):\n            return -1\n\n    if arr[int(prev)] == x:\n        return int(prev)\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    list = [1, 2, 3, 4, 5]\n    value = 4\n    n = len(list)\n    print(jump_search(list, value, n))\n",
  "r": "jump_search <- function(arr, x) {\n  n <- length(arr)\n  block_size <- floor(sqrt(n))\n  \n  prev <- 0\n  while (arr[min(block_size, n)] < x) {\n    prev <- block_size\n    block_size <- block_size + floor(sqrt(n))\n    if (prev >= n) {\n      return(-1)\n    }\n  }\n  \n  while (arr[prev] < x) {\n    prev <- prev + 1\n    if (prev == min(block_size, n)) {\n      return(-1)\n    }\n  }\n  \n  if (arr[prev] == x) {\n    return(prev)\n  }\n  \n  return(-1)\n}\n\n# Example usage\narr <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nx <- 7\nresult <- jump_search(arr, x)\n\nif (result != -1) {\n  cat(\"Element found at index\", result, \"\\n\")\n} else {\n  cat(\"Element not found in the array\\n\")\n}\n",
  "rust": "use std::io;\n\nfn jump_search(arr: &[i32], x: i32) -> Option<usize> {\n    let n = arr.len();\n\n    let block_size = (n as f64).sqrt() as usize;\n\n   \n    let mut block_idx = 0;\n    while block_idx < n && arr[block_idx] < x {\n        block_idx += block_size;\n    }\n    let mut i = block_idx - block_size;\n    while i < n && arr[i] < x {\n        i += 1;\n    }\n    if i < n && arr[i] == x {\n        Some(i)\n    } else {\n        None\n    }\n}\n\nfn main() {\n    \n    println!(\"Enter a sorted list of integers separated by spaces:\");\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n\n    let arr: Vec<i32> = input\n        .trim()\n        .split_whitespace()\n        .filter_map(|s| s.parse().ok())\n        .collect();\n\n    println!(\"Enter the element to search:\");\n    let mut search_element = String::new();\n    io::stdin()\n        .read_line(&mut search_element)\n        .expect(\"Failed to read line\");\n\n    let x: i32 = search_element.trim().parse().expect(\"Invalid input\");\n\n   \n    match jump_search(&arr, x) {\n        Some(index) => println!(\"Element {} found at index {}\", x, index),\n        None => println!(\"Element {} not found in the list\", x),\n    }\n}\n",
  "languages": [
    "c",
    "c-plus-plus",
    "c-sharp",
    "java",
    "javascript",
    "kotlin",
    "ruby",
    "scala",
    "swift",
    "typescript",
    "julia",
    "dart",
    "go",
    "haskell",
    "php",
    "perl",
    "python",
    "r",
    "rust"
  ]
}