{
  "slug": "find-the-eigenvectors-of-a-matrix",
  "title": "Find The Eigenvectors Of A Matrix",
  "c": "#include <stdio.h>\n#include <gsl/gsl_eigen.h>\n\nint main() {\n    gsl_matrix *mat = gsl_matrix_alloc(3, 3); // Create a 3x3 matrix\n    gsl_matrix_set(mat, 0, 0, 1);\n    gsl_matrix_set(mat, 0, 1, 2);\n    gsl_matrix_set(mat, 0, 2, 3);\n    gsl_matrix_set(mat, 1, 0, 4);\n    gsl_matrix_set(mat, 1, 1, 5);\n    gsl_matrix_set(mat, 1, 2, 6);\n    gsl_matrix_set(mat, 2, 0, 7);\n    gsl_matrix_set(mat, 2, 1, 8);\n    gsl_matrix_set(mat, 2, 2, 9);\n\n    gsl_vector_complex *eval = gsl_vector_complex_alloc(3); // Eigenvalues\n    gsl_matrix_complex *evec = gsl_matrix_complex_alloc(3, 3); // Eigenvectors\n\n    gsl_eigen_nonsymmv_workspace *workspace = gsl_eigen_nonsymmv_alloc(3);\n    gsl_eigen_nonsymmv(mat, eval, evec, workspace);\n\n    gsl_eigen_nonsymmv_free(workspace);\n\n    gsl_eigen_nonsymmv_sort(eval, evec, GSL_EIGEN_SORT_ABS_DESC);\n\n    printf(\"Eigenvectors:\\n\");\n    for (int i = 0; i < 3; i++) {\n        printf(\"[\");\n        for (int j = 0; j < 3; j++) {\n            gsl_complex z = gsl_matrix_complex_get(evec, j, i);\n            printf(\"%f, \", GSL_REAL(z));\n        }\n        printf(\"]\\n\");\n    }\n\n    gsl_matrix_free(mat);\n    gsl_vector_complex_free(eval);\n    gsl_matrix_complex_free(evec);\n\n    return 0;\n}\n",
  "c-plus-plus": "#include <iostream>\n#include <Eigen/Dense>\n\nusing namespace std;\nusing namespace Eigen;\n\n// Eigen library is used to find the eigen vector of a given matrix.\n// Eigen Library was downloaded from: https://gitlab.com/libeigen/eigen/-/archive/3.4.0/eigen-3.4.0.tar.bz2\n// Extracted and copied the folder \"Eigen\" into /usr/local/include using Linux Debian.\n// Or use a package manager to install Eigen like \"vcpkg\" for windows.\n// Referene code: https://eigen.tuxfamily.org/dox/classEigen_1_1EigenSolver.html#a66288022802172e3ee059283b26201d7\n\n// Returning the eigenvectors as MatrixXd type\nMatrixXd eigenvectors(MatrixXd matrix_egv)\n{\n    EigenSolver<MatrixXd> eigenSolv(matrix_egv);\n    MatrixXd eigen_m = eigenSolv.eigenvectors().real();\n\n    return eigen_m;\n}\n\n// eigenvectors help\nvoid eigenvectors_help() \n{\n    cout << \"Eigenvectors: \" << endl;\n    cout << \"Only sqare Matrixes can be processed.\" << endl;\n    cout << \"The equation to solve is: AV = 位V.\" << endl;\n    cout << \"Where:\" << endl;\n    cout << \"A is the square given matrix.\" << endl;\n    cout << \"V is the eigenvectors to calculate and return as MatrixXd type.\" << endl;\n    cout << \"位 is the eigenvalues.\" << endl << endl;\n}\n\n// example of use\nvoid eigenvectors_example() \n{\n    MatrixXd matrix_egv(3, 3);\n    matrix_egv << 1, 2, 3, 4, 5, 6, 7, 8, 9;\n    cout << \"Eigenvectors example:\" << endl;\n    cout << \"Here is a square matrix m[3x3]:\\n\" << matrix_egv << endl;\n    cout << \"Created as follow:\" << endl;\n    cout << \"MatrixXd matrix_egv(3, 3);\" << endl;\n    cout << \"matrix_egv << 1, 2, 3, 4, 5, 6, 7, 8, 9;\" << endl;\n    cout << \"Now, calling the function:\" << endl;\n    cout << \"eigenvectors(matrix_egv)\" << endl;\n    cout << \"The eigenvectors are: \" << endl << eigenvectors(matrix_egv) << endl;\n    cout << \"It will return the eigenvectors as MatrixXd type.\" << endl;\n}\n\nint main ()\n{\n    eigenvectors_help();\n    cout << endl;\n    eigenvectors_example();\n\n    return 0;\n}",
  "java": "import org.apache.commons.math3.linear.*;\n\npublic class Eigenvectors {\n    public static void main(String[] args) {\n        // Input matrix\n        RealMatrix matrix = new Array2DRowRealMatrix(new double[][]{\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        });\n\n        // Eigen decomposition\n        EigenDecomposition decomposition = new EigenDecomposition(matrix);\n\n        // Eigenvalues\n        RealVector eigenvalues = decomposition.getRealEigenvalues();\n        System.out.println(\"Eigenvalues: \" + eigenvalues);\n\n        // Eigenvectors\n        RealMatrix eigenvectors = decomposition.getV();\n        System.out.println(\"Eigenvectors:\");\n        for (int i = 0; i < eigenvectors.getColumnDimension(); i++) {\n            RealVector eigenvector = eigenvectors.getColumnVector(i);\n            System.out.println(eigenvector);\n        }\n    }\n}\n",
  "javascript": "const math = require(\"mathjs\");\n\nconst matrixArray = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\n\nconst matrix = math.matrix(matrixArray);\nconst eigDecomp = math.eigs(matrix);\n\nconst eigVectors = eigDecomp.vectors;\nconst eigVectorsT = math.transpose(eigVectors); // Transpose to get row vectors\n\nconsole.log(math.format(eigVectorsT, { precision: 10, columnSeparator: \"  \" })); // Print with precision 10 and column separator '  '\n",
  "kotlin": "import org.apache.commons.math3.linear.*\n\nfun main(args: Array<String>) {\n    val matrix: RealMatrix = Array2DRowRealMatrix(\n        arrayOf(\n            doubleArrayOf(1.0, 2.0, 3.0),\n            doubleArrayOf(4.0, 5.0, 6.0),\n            doubleArrayOf(7.0, 8.0, 9.0)\n        )\n    )\n\n    val decomposition = EigenDecomposition(matrix)\n\n    val eigenvalues: RealVector = decomposition.getRealEigenvalues()\n    val eigenvectors: RealMatrix = decomposition.getV()\n\n    for (i in 0 until eigenvectors.getColumnDimension()) {\n        val eigenvector: RealVector = eigenvectors.getColumnVector(i)\n        System.out.println(eigenvector)\n    }\n}\n",
  "typescript": "function eigenvectors(matrix: number[][]) {\n  const n = matrix.length;\n  const eigenvalues = calculateEigenvalues(matrix);\n\n  const eigenvectors = [];\n  for (let i = 0; i < n; i++) {\n    const lambda = eigenvalues[i];\n    const aMinusLambdaI = subtractScalar(matrix, lambda);\n    const nullspace = calculateNullspace(aMinusLambdaI);\n    eigenvectors.push(normalize(nullspace));\n  }\n\n  return eigenvectors;\n}\n\nfunction calculateEigenvalues(matrix: number[][]) {\n  // TODO: Implement eigenvalue calculation\n  // This is beyond the scope of this question.\n  // We can assume that the eigenvalues are given as input.\n  const eigenvalues = [0, 0, 0]; // Example values\n  return eigenvalues;\n}\n\nfunction subtractScalar(matrix: number[][], scalar: number) {\n  const n = matrix.length;\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    const row = [];\n    for (let j = 0; j < n; j++) {\n      row.push(matrix[i][j] - scalar * (i === j ? 1 : 0));\n    }\n    result.push(row);\n  }\n  return result;\n}\n\nfunction calculateNullspace(matrix: number[][]) {\n  // TODO: Implement nullspace calculation\n  // This can be done using Gaussian elimination or other methods.\n  // For simplicity, we can assume that the nullspace is given as input.\n  const nullspace = [0, 0, 0]; // Example values\n  return nullspace;\n}\n\nfunction normalize(vector: number[]) {\n  const length = Math.sqrt(vector.reduce((sum, x) => sum + x * x, 0));\n  return vector.map((x) => x / length);\n}\n\n// Example usage:\nconst matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\nconst eigenvectors = eigenvectors(matrix);\nconsole.log(eigenvectors);\n",
  "description": "\n## Write a program to find the eigenvectors of a matrix\n\nThe eigenvalues and eigenvectors of a linear transformation are the values and vectors that determine the transformation. The eigenvectors of a matrix A are the vectors v for which the matrix equation Av = 位v has a non-trivial solution.\n\n```txt\nInput  :\n1 2 3\n4 5 6\n7 8 9\n\nOutput :\n[[-0.23197068724628608, -0.7858302387246789, 0.4082482904638631],\n [-0.5253220933012334, -0.08675134095039447, -0.8164965809277261],\n [-0.8186734993561807, 0.6123275568238899, 0.4082482904638631]]\n```\n\n---\n",
  "trackId": 3169,
  "lastUpdated": "2024-05-13T17:36:45Z",
  "contributors": [
    "WentuM",
    "anandfresh",
    "MadhuS-1605",
    "cshdev110",
    "harshraj8843",
    "NavneetBende",
    "Ishay1997",
    "dsarussi",
    "vishalsingh2972",
    "joao-vitor-souza"
  ],
  "julia": "using LinearAlgebra\nA = [1 2 3; 4 5 6; 7 8 9]\nprintln(eigvecs(A))\n",
  "go": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"gonum.org/v1/gonum/blas/blas64\"\n    \"gonum.org/v1/gonum/mat\"\n    \"gonum.org/v1/gonum/lapack/lapack64\"\n)\n\nfunc main() {\n    // Define the matrix A for which you want to find eigenvectors.\n    data := []float64{2, -1, 0, -1, 3, -1, 0, -1, 2}\n    rows, cols := 3, 3\n    a := mat.NewDense(rows, cols, data)\n\n    // Compute the eigenvalues and eigenvectors.\n    eig := mat.Eigen{}\n    ok := eig.Factorize(a, false)\n    if !ok {\n        log.Fatal(\"Eigenvalue factorization failed.\")\n    }\n\n    // Get the eigenvalues and eigenvectors.\n    eigenvalues := eig.Values(nil)\n    eigenvectors := eig.VectorsTo(nil)\n\n    // Print the eigenvalues.\n    fmt.Println(\"Eigenvalues:\")\n    for i, val := range eigenvalues {\n        fmt.Printf(\"位%d = %v\\n\", i+1, val)\n    }\n\n    // Print the eigenvectors.\n    fmt.Println(\"\\nEigenvectors:\")\n    for i := 0; i < cols; i++ {\n        eigenvector := eigenvectors.ColView(i)\n        fmt.Printf(\"v%d = %v\\n\", i+1, mat.Formatted(eigenvector.T(), mat.Prefix(\"\"), mat.Squeeze()))\n    }\n}\n",
  "python": "import numpy as np\n\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\neig_value, eig_vector = np.linalg.eig(matrix)\n\nprint(eig_vector)\n\n\"\"\"Output\n[[-0.23197069 -0.78583024  0.40824829]\n [-0.52532209 -0.08675134 -0.81649658]\n [-0.8186735   0.61232756  0.40824829]\n\"\"\"\n",
  "r": "A = matrix(c(1:9), 3, 3) \ncat(\"The 3x3 matrix:\\n\") \nprint(A) \nprint(eigen(A)) \n",
  "languages": [
    "c",
    "c-plus-plus",
    "java",
    "javascript",
    "kotlin",
    "typescript",
    "julia",
    "go",
    "python",
    "r"
  ]
}