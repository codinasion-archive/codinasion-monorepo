{
  "slug": "implement-binary-search",
  "title": "Implement Binary Search",
  "c": "#include <stdio.h>\n\nint binarySearch(int ARay[], int thing, int findThis) \n{\n    int lowerBound = 0;\n    int upperBound = thing - 1;\n\n    while (lowerBound <= upperBound) \n    {\n        int mid = lowerBound + (upperBound - lowerBound) / 2;\n\n        if (ARay[mid] == findThis) \n        {\n            return mid;\n        }\n        else if (ARay[mid] < findThis) \n        {\n            lowerBound = mid + 1;\n        }\n        else \n        {\n            upperBound = mid - 1;\n        }\n    }\n    return -1;\n}\n\nint main() \n{\n    int ARay[] = { 1, 2, 3, 4, 5 };\n    int thing = sizeof(ARay) / sizeof(ARay[0]);\n    int findThis = 4;\n\n    int neededThing = binarySearch(ARay, thing, findThis);\n\n    if (neededThing != -1) \n    {\n        printf(\"Element found! It is located at index %d\\n\", neededThing);\n    }\n    else \n    {\n        printf(\"ERROR! The given element does not exist in the current array :(\\n\");\n    }\n    return 0;\n}\n\n/* Cautiously Crafted By Redzwinger */",
  "c-plus-plus": "#include <bits/stdc++.h>\nusing namespace std;\n\nint binarySearch(int arr[], int size, int key) {\n  int low = 0;\n  int high = size - 1;\n  while (low <= high) {\n    int mid = low + (high - low) / 2;\n    if (arr[mid] == key) {\n      return mid;\n    } else if (arr[mid] < key) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return -1;\n}\n\nint main() {\n  int size;\n  cout << \"Enter the size of the array: \";\n  cin >> size;\n  int arr[size];\n  cout << \"Enter the elements of the array in sorted order:\\n\";\n  for (int i = 0; i < size; ++i) {\n    cout << \"Enter element \" << (i + 1) << \": \";\n    cin >> arr[i];\n  }\n  int key;\n  cout << \"Enter the key to search: \";\n  cin >> key;\n  int result = binarySearch(arr, size, key);\n  if (result != -1) {\n    cout << \"Element found at index: \" << result << endl;\n  } else {\n    cout << \"Element not found in the array.\" << endl;\n  }\n  return 0;\n}\n",
  "c-sharp": "using System;\n\npublic class HelloWorld\n{\n    static int BinarySearch(int[] array, int size, int value)\n    {\n        int lowerBound = 0;\n        int upperBound = size - 1;\n\n        while (lowerBound <= upperBound)\n        {\n            int midPoint = lowerBound + (upperBound - lowerBound) / 2;\n\n            if (array[midPoint] < value)\n            {\n                lowerBound = midPoint + 1;\n            }\n            else if (array[midPoint] > value)\n            {\n                upperBound = midPoint - 1;\n            }\n            else\n            {\n                return midPoint; \n            }\n        }\n\n        return -1; \n    }\n\n    static void Main()\n    {\n        Console.Write(\"Enter sorted array elements separated by space: \");\n        string[] inputArray = Console.ReadLine().Split(' ');\n\n        int[] array = Array.ConvertAll(inputArray, int.Parse);\n\n        Console.Write(\"Enter the value to search: \");\n        int valueToSearch = int.Parse(Console.ReadLine());\n\n        int index = BinarySearch(array, array.Length, valueToSearch);\n\n        if (index != -1)\n        {\n            Console.WriteLine($\"Value {valueToSearch} found at index {index}.\");\n        }\n        else\n        {\n            Console.WriteLine($\"Value {valueToSearch} not found in the array.\");\n        }\n    }\n\n\n}\n",
  "f-sharp": "let rec binarySearch (arr: 'a[]) (x: 'a) (lowerBound: int) (upperBound: int) : int =\n    if upperBound < lowerBound then\n        -1 // x does not exist\n    else\n        let midPoint = lowerBound + (upperBound - lowerBound) / 2\n        if arr.[midPoint] < x then\n            binarySearch arr x (midPoint + 1) upperBound\n        elif arr.[midPoint] > x then\n            binarySearch arr x lowerBound (midPoint - 1)\n        else\n            midPoint // x found at midPoint\n\n// Example usage\nlet arr = [|2; 3; 4; 10; 40|]\nlet x = 10\nlet result = binarySearch arr x 0 (Array.length arr - 1)\nif result <> -1 then\n    printfn \"Element %d is present at index %d\" x result\nelse\n    printfn \"Element %d is not present in array\" x\n",
  "java": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class ImplementBinarySearch {\n\n    public static int binarysearch(int arr[],int value){\n\n        int low = 0;\n        int high = arr.length - 1;\n        \n        while(low <= high){\n            int mid = (low+high)/2;\n\n            if(arr[mid] == value){\n                return mid;\n            }\n           else if(value < arr[mid]){\n                high = mid - 1;\n            }\n            else{\n                low = mid + 1;\n            }\n\n        }\n        return -1;\n    }\n    public static void main(String[] args){\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.println(\"Enter the size of the array:\");\n        int size = scanner.nextInt();\n\n        int[] inputArray = new int[size];\n\n        System.out.println(\"Enter the elements of the array:\");\n        for(int i=0;i<size;i++){\n            inputArray[i] = scanner.nextInt();\n        }\n\n        Arrays.sort(inputArray);\n\n        System.out.println(\"Enter the value to search:\");\n       \n        int searchValue = scanner.nextInt();\n\n        int result = binarysearch(inputArray, searchValue);\n\n        if(result != -1){\n            System.out.println(\"Element found at index: \" + result);\n        }\n        else{\n            System.out.println(\"Element not found in the array.\");\n        }\n\n        scanner.close();\n\n\n    }   \n\n}\n",
  "javascript": "function binarySearch(arr, x) {\n    let lowerBound = 0;\n    let upperBound = arr.length - 1;\n\n    while (lowerBound <= upperBound) {\n        let midPoint = Math.floor((lowerBound + upperBound) / 2);\n\n        if (arr[midPoint] === x) {\n            return midPoint; // Element found, return index\n        } else if (arr[midPoint] < x) {\n            lowerBound = midPoint + 1; // Search in the right half\n        } else {\n            upperBound = midPoint - 1; // Search in the left half\n        }\n    }\n\n    return -1; // Element not found\n}\n\n// Example usage\nconst list = [1, 2, 3, 4, 5];\nconst value = 4;\n\nconst index = binarySearch(list, value);\nif (index !== -1) {\n    console.log(\"Output:\", index); // Output: 3\n} else {\n    console.log(\"Element not found.\");\n}\n",
  "kotlin": "fun main() {\n    println(binarySearch(intArrayOf(1, 2, 3, 4, 5),4))\n}\n\n/**\n* A search algorithm that finds the index of a target value within a sorted array.\n* Running time complexity: O(log n)\n* \n* list = [1,2,3,4,5]\n* value = 4\n* Output : 3\n* \n */\n\nfun binarySearch(A: IntArray, target: Int): Int {\n    if(A.size == 0) return -1;\n\n    var low = 0\n    var high = A.size - 1\n\n    while(low <= high) {\n        val mid = low + (high - low) / 2\n\n        if(A[mid] == target) {\n            return mid;\n        } else if(A[mid] < target) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    return -1;\n}",
  "ruby": "def binary_search(arr, x)\n  lower_bound = 0\n  upper_bound = arr.length - 1\n\n  while lower_bound <= upper_bound\n    mid_point = lower_bound + (upper_bound - lower_bound) / 2\n\n    if arr[mid_point] < x\n      lower_bound = mid_point + 1\n    elsif arr[mid_point] > x\n      upper_bound = mid_point - 1\n    else\n      return mid_point # x found at mid_point\n    end\n  end\n\n  return -1 # x does not exist\nend\n\n# Example usage\narr = [2, 3, 4, 10, 40]\nx = 10\n\nresult = binary_search(arr, x)\nif result != -1\n  puts \"Element #{x} is present at index #{result}\"\nelse\n  puts \"Element #{x} is not present in array\"\nend\n",
  "typescript": "function binarySearch(arr: number[], x: number): number {\n    let lowerBound: number = 0;\n    let upperBound: number = arr.length - 1;\n\n    while (lowerBound <= upperBound) {\n        const midPoint: number = Math.floor((lowerBound + upperBound) / 2);\n\n        if (arr[midPoint] === x) {\n            return midPoint; // Element found, return index\n        } else if (arr[midPoint] < x) {\n            lowerBound = midPoint + 1; // Search in the right half\n        } else {\n            upperBound = midPoint - 1; // Search in the left half\n        }\n    }\n\n    return -1; // Element not found\n}\n\n// Example usage:\nconst list: number[] = [1, 2, 3, 4, 5];\nconst value: number = 4;\nconst index: number = binarySearch(list, value);\nconsole.log(\"Output:\", index); // Output: 3\n",
  "description": "\n## Write a program to implement binary search\n\nBinary search is a fast search algorithm with run-time complexity of Ο(log n). This search algorithm works on the principle of divide and conquer. For this algorithm to work properly, the data collection should be in the sorted form.\r\n\r\nBinary search looks for a particular item by comparing the middle most item of the collection. If a match occurs, then the index of item is returned. If the middle item is greater than the item, then the item is searched in the sub-array to the left of the middle item. Otherwise, the item is searched for in the sub-array to the right of the middle item. This process continues on the sub-array as well until the size of the subarray reduces to zero.\r\n\r\n### Pseudocode\r\n\r\n```text\r\nprocedure binary_search\r\n   A ← sorted array\r\n   n ← size of array\r\n   x ← value to be searched\r\n\r\n   Set lowerBound = 1\r\n   Set upperBound = n\r\n\r\n   while x not found\r\n      if upperBound < lowerBound\r\n         EXIT: x does not exists.\r\n   \r\n      set midPoint = lowerBound + ( upperBound - lowerBound ) / 2\r\n      \r\n      if A[midPoint] < x\r\n         set lowerBound = midPoint + 1\r\n         \r\n      if A[midPoint] > x\r\n         set upperBound = midPoint - 1 \r\n\r\n      if A[midPoint] = x \r\n         EXIT: x found at location midPoint\r\n   end while\r\n   \r\nend procedure\r\n```\r\n\r\n### Example\r\n\r\n```text\r\nlist = [1,2,3,4,5]\r\nvalue = 4\r\n\r\nOutput : 3\r\n```\n\n---\n",
  "trackId": 5192,
  "lastUpdated": "2024-06-25T18:29:11Z",
  "contributors": [
    "Riyazul555",
    "harshraj8843",
    "Parvezkhan0",
    "itskarelleh",
    "grinish21",
    "srini696",
    "srivamsidandu",
    "Redzwinger",
    "prathebaAT",
    "amananand20",
    "Shivamk034",
    "Amedi-Imbira"
  ],
  "julia": "function binary_search(arr, x)\n    lower_bound = 1\n    upper_bound = length(arr)\n    \n    while lower_bound <= upper_bound\n        mid_point = lower_bound + (upper_bound - lower_bound) ÷ 2\n        \n        if arr[mid_point] < x\n            lower_bound = mid_point + 1\n        elseif arr[mid_point] > x\n            upper_bound = mid_point - 1\n        else\n            return mid_point  # x found at mid_point\n        end\n    end\n    \n    return -1  # x does not exist\nend\n\n# Example usage\narr = [2, 3, 4, 10, 40]\nx = 10\n\nresult = binary_search(arr, x)\nif result != -1\n    println(\"Element $x is present at index $result\")\nelse\n    println(\"Element $x is not present in array\")\nend\n",
  "scala": "object HelloWorld {\n\n  def binarySearch(arr: Array[Int], n: Int, x: Int): Int = {\n    var lowerBound = 0\n    var upperBound = n - 1\n\n    while (lowerBound <= upperBound) {\n      val midPoint = lowerBound + (upperBound - lowerBound) / 2\n\n      if (arr(midPoint) < x)\n        lowerBound = midPoint + 1\n      else if (arr(midPoint) > x)\n        upperBound = midPoint - 1\n      else\n        return midPoint // Element found\n    }\n\n    -1 // Element not found\n  }\n\n  def main(args: Array[String]): Unit = {\n    // User input\n    print(\"Enter the sorted array (comma-separated): \")\n    val inputArray = scala.io.StdIn.readLine().split(\",\").map(_.toInt)\n\n    print(\"Enter the size of the array: \")\n    val size = scala.io.StdIn.readInt()\n\n    print(\"Enter the value to be searched: \")\n    val valueToSearch = scala.io.StdIn.readInt()\n\n    val result = binarySearch(inputArray, size, valueToSearch)\n\n    if (result != -1)\n      println(s\"Element $valueToSearch found at index $result\")\n    else\n      println(s\"Element $valueToSearch not found in the array\")\n  }\n}\n",
  "dart": "int binarySearch(List<int> arr, int x) {\n  int lowerBound = 0;\n  int upperBound = arr.length - 1;\n\n  while (lowerBound <= upperBound) {\n    int midPoint = (lowerBound + upperBound) ~/ 2;\n\n    if (arr[midPoint] == x) {\n      return midPoint;                //Element found return it's index\n    } else if (arr[midPoint] < x) {\n      lowerBound = midPoint + 1;      //Search in the right half\n    } else {\n      upperBound = midPoint - 1;      //Search in the left half\n    }\n  }\n  return -1;\n}\n\nvoid main() {\n  //Example Usage\n  List<int> sortedArray = [1, 2, 3, 4, 5];\n  int valueToSearch = 4;\n\n  int resultIndex = binarySearch(sortedArray, valueToSearch);\n\n  if (resultIndex != -1) {\n    print('Elemenet $valueToSearch found at index $resultIndex');\n  } else {\n    print('Element $valueToSearch not found in the array');\n  }\n}\n",
  "go": "package main\n\nimport (\n    \"fmt\"\n)\n\nfunc binarySearch(sortedArray []int, findThis int) int {\n    lowerBound := 0\n    upperBound := len(sortedArray) - 1\n\n    for lowerBound <= upperBound {\n        mid := lowerBound + (upperBound-lowerBound)/2\n\n        if sortedArray[mid] == findThis {\n            return mid\n        } else if sortedArray[mid] < findThis {\n            lowerBound = mid + 1\n        } else {\n            upperBound = mid - 1\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    sortedArray := []int{1, 2, 3, 4, 5, 6, 7}\n    searchForNumber := 4\n    foundAtIndex := binarySearch(sortedArray, searchForNumber)\n\n    if foundAtIndex != -1 {\n        fmt.Printf(\"Element %d located at index %d\\n\", searchForNumber, foundAtIndex)\n    } else {\n        fmt.Printf(\"Element %d not found !!!\", searchForNumber)\n    }\n}\n\n/* Cautiously Crafted By Redzwinger */\n",
  "haskell": "-- Binary search function\nbinarySearch :: (Ord a) => [a] -> a -> Int\nbinarySearch arr x = binarySearchHelper arr x 0 (length arr - 1)\n\n-- Helper function to perform the binary search\nbinarySearchHelper :: (Ord a) => [a] -> a -> Int -> Int -> Int\nbinarySearchHelper arr x lowerBound upperBound\n  | upperBound < lowerBound = -1  -- x does not exist\n  | arr !! midPoint < x      = binarySearchHelper arr x (midPoint + 1) upperBound\n  | arr !! midPoint > x      = binarySearchHelper arr x lowerBound (midPoint - 1)\n  | otherwise                = midPoint  -- x found at midPoint\n  where\n    midPoint = lowerBound + (upperBound - lowerBound) `div` 2\n\n-- Example usage\nmain :: IO ()\nmain = do\n    let arr = [2, 3, 4, 10, 40]\n    let x = 10\n    let result = binarySearch arr x\n    if result /= -1\n        then putStrLn $ \"Element \" ++ show x ++ \" is present at index \" ++ show result\n        else putStrLn $ \"Element \" ++ show x ++ \" is not present in array\"\n",
  "php": "<?php\n\nfunction binary_search($arr, $x) {\n    $lowerBound = 0;\n    $upperBound = count($arr) - 1;\n\n    while ($upperBound >= $lowerBound) {\n        $midPoint = floor(($upperBound + $lowerBound) / 2);\n\n        if ($arr[$midPoint] < $x) {\n            $lowerBound = $midPoint + 1;\n        } elseif ($arr[$midPoint] > $x) {\n            $upperBound = $midPoint - 1;\n        } else {\n            return $midPoint;\n        }\n    }\n\n    return -1; // Not found\n}\n\n// Example usage:\n$list = [1, 2, 3, 4, 5];\n$value = 4;\n$result = binary_search($list, $value);\n\nif ($result != -1) {\n    echo \"Value $value found at index $result\";\n} else {\n    echo \"Value $value not found in the list\";\n}\n?>\n",
  "perl": "sub binary_search {\n    my ($arr, $value) = @_;\n    my $low = 0;\n    my $high = scalar(@$arr) - 1;\n\n    while ($low <= $high) {\n        my $mid = int(($low + $high) / 2);\n        if ($arr->[$mid] == $value) {\n            return $mid;  # Found the value\n        } elsif ($arr->[$mid] < $value) {\n            $low = $mid + 1;  # Value is in the upper half\n        } else {\n            $high = $mid - 1;  # Value is in the lower half\n        }\n    }\n\n    return -1;  # Value not found\n}\n\nmy @list = (1, 2, 3, 4, 5);\nmy $value = 4;\nmy $index = binary_search(\\@list, $value);\nif ($index != -1) {\n    print \"Output: $index\\n\";\n} else {\n    print \"Value not found\\n\";\n}\n",
  "python": "def main():\n    seq = 1, 2, 3, 4, 5, 6, 7  # Test here. Seq should be sorted\n    print(binary_search(seq, 90))\n\n\ndef binary_search(data, target):\n    \"\"\"\n    locating a target value within a sorted sequence\n    return True if target is found\n    \"\"\"\n    left = 0\n    right = len(data) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if target == data[mid]:  # Found match!\n            return True\n        elif target < data[mid]:  # Search values left of mid\n            right = mid - 1\n        else:  # Search values right of mid\n            left = mid + 1\n    return False  # loop ended without success\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "r": "binary_search <- function(A, x) {\n  lowerBound <- 1\n  upperBound <- length(A)\n  \n  while (upperBound >= lowerBound) {\n    midPoint <- lowerBound + floor((upperBound - lowerBound) / 2)\n    \n    if (A[midPoint] == x) {\n      return(midPoint)\n    } else if (A[midPoint] < x) {\n      lowerBound <- midPoint + 1\n    } else {\n      upperBound <- midPoint - 1\n    }\n  }\n  \n  return(-1)  # If not found\n}\n\n# Example usage:\nlist <- c(1, 2, 3, 4, 5)\nvalue <- 4\nresult <- binary_search(list, value)\nif (result != -1) {\n  cat(\"Output:\", result, \"\\n\")\n} else {\n  cat(\"Value not found\\n\")\n}\n",
  "rust": "use std::io;\n\nfn binary_search(arr: &[i32], key: i32) -> Option<usize> {\n  let mut low = 0;\n  let mut high = arr.len() - 1;\n\n  while low <= high {\n    let mid = low + (high - low) / 2;\n\n    if arr[mid] == key {\n      return Some(mid);\n    } else if arr[mid] < key {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  None\n}\n\nfn main() {\n  let size: usize = read_input();\n  let mut arr = read_array(size);\n  let key: i32 = read_input();\n\n  match binary_search(&arr, key) {\n    Some(result) => println!(\"Element found at index: {}\", result),\n    None => println!(\"Element not found in the array.\"),\n  }\n}\n\nfn read_input<T>() -> T\nwhere\n  T: std::str::FromStr,\n  T::Err: std::fmt::Debug,\n{\n  let mut input = String::new();\n  io::stdin().read_line(&mut input).expect(\"Failed to read input\");\n  input.trim().parse().expect(\"Invalid input\")\n}\n\nfn read_array(size: usize) -> Vec<i32> {\n  (0..size)\n    .map(|_| read_input())\n    .collect()\n}\n",
  "languages": [
    "c",
    "c-plus-plus",
    "c-sharp",
    "f-sharp",
    "java",
    "javascript",
    "kotlin",
    "ruby",
    "typescript",
    "julia",
    "scala",
    "dart",
    "go",
    "haskell",
    "php",
    "perl",
    "python",
    "r",
    "rust"
  ]
}