{
  "slug": "find-the-adjoint-of-a-matrix",
  "title": "Find The Adjoint Of A Matrix",
  "c": "#include <stdio.h>\n\nint findMinorAndSign(int a[3][3], int row, int col)\n{\n    int detM[4], p = 0;\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            if (i != row && j != col)\n            {\n                detM[p++] = a[i][j];\n            }\n        }\n    }\n\n    int detValue = detM[0] * detM[3] - detM[1] * detM[2];\n\n    if ((row + col) % 2 == 1)\n    {\n        detValue *= -1;\n    }\n\n    return detValue;\n}\n\nvoid printMatrix(int a[3][3])\n{\n    printf(\"[\");\n    for (int i = 0; i < 3; i++)\n    {\n        printf(\"[\");\n        for (int j = 0; j < 3; j++)\n        {\n            printf(\"%d\", a[i][j]);\n            if (j != 2)\n            {\n                printf(\", \");\n            }\n        }\n        printf(\"]\");\n        if (i != 2)\n        {\n            printf(\", \");\n        }\n    }\n\n    printf(\"]\\n\");\n}\n\nvoid coFactorMatrix(int input[3][3], int output[3][3])\n{\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            output[i][j] = findMinorAndSign(input, i, j);\n        }\n    }\n}\n\nvoid transposeMatrix(int input[3][3], int output[3][3])\n{\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            output[j][i] = input[i][j];\n        }\n    }\n}\n\nint main()\n{\n    int input[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n\n    int coFactors[3][3];\n    coFactorMatrix(input, coFactors);\n\n    int adjoints[3][3];\n    transposeMatrix(coFactors, adjoints);\n\n    printMatrix(adjoints);\n}",
  "c-plus-plus": "#include <cstddef>\n#include <cmath>\n#include <vector>\n#include <initializer_list>\n\nclass Matrix\n{\n    std::vector<int> m_data;\n    int m_size{};\n\npublic:\n    Matrix() = default;\n    Matrix(std::initializer_list<int> l);\n\n    int determinant();\n    void set_elements(std::initializer_list<int> l);\n    bool is_squared(int num);\n    Matrix adjoint();\n    int size() const { return m_size; }\n    Matrix get_submatrix(int i, int k) const;\n\n    int operator[](std::size_t idx) const { return (idx >= 0 && idx < m_data.size()) ? m_data.at(idx) : 0; }\n\nprivate:\n    void add_last(int element);\n};\n\nint Matrix::determinant()\n{\n    if (m_size == 1)\n    {\n        return m_data[0];\n    }\n    int sign, det = 0;\n    for (int r, c, i = 0; i < m_data.size() / 2; i++)\n    {\n        r = static_cast<int>(i / m_size);\n        c = i % m_size;\n        auto sub_matrix = get_submatrix(r, c);\n        sign = ((r + c) % 2 == 0) ? 1 : -1;\n        det += sign * m_data.at(i) * sub_matrix.determinant();\n    }\n    return det;\n}\n\nMatrix Matrix::get_submatrix(int r, int c) const\n{\n    Matrix m;\n    for (int i = 0; i < m_data.size(); i++)\n    {\n        if (r == static_cast<int>(i / m_size) || c == i % m_size)\n        {\n            continue;\n        }\n        m.add_last(m_data.at(i));\n    }\n    return m;\n}\n\nbool Matrix::is_squared(int num)\n{\n    auto sqrt_num = static_cast<int>(std::sqrt(num));\n    return num == (sqrt_num * sqrt_num);\n}\n\nvoid Matrix::add_last(int element)\n{\n    m_data.push_back(element);\n    m_size = static_cast<int>(std::sqrt(m_data.size()));\n}\n\nMatrix Matrix::adjoint()\n{\n    Matrix adjoint_matrix;\n\n    if (m_size == 1)\n    {\n        adjoint_matrix.set_elements({1});\n    }\n    for (int sign, c, r, i = 0; i < m_data.size(); i++)\n    {\n        r = static_cast<int>(i / m_size);\n        c = i % m_size;\n        auto sub_matrix = get_submatrix(r, c);\n        sign = ((r + c) % 2 == 0) ? 1 : -1;\n        adjoint_matrix.add_last(sign * sub_matrix.determinant());\n    }\n\n    return adjoint_matrix;\n}\n\nvoid Matrix::set_elements(std::initializer_list<int> l)\n{\n    if (!is_squared(l.size()))\n    {\n        return;\n    }\n    m_data.insert(m_data.begin(), l);\n    m_size = std::sqrt(l.size());\n}\n",
  "c-sharp": "using System;\n\nclass FindTheAdjointOfAMatrix {\n\n    /// <summary>\n    /// The function that calculates the adjoint of a matrix\n    /// </summary>\n    public static int[,] GetAdjoint(int[,] matrix) {\n\n        // Getting the size of the matrix (square matrix)\n        int n = matrix.GetLength(0);\n        // Creating a 2D array to store the adjoint matrix\n        int[,] adjoint = new int[n, n];\n\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                // Getting the cofactor of the matrix[i, j]\n                int[,] cofactor = GetCofactor(matrix, i, j);\n                // Calculating the sign for the current element\n                int sign = (int)Math.Pow(-1, i + j);\n                // Calculating the determinant of the cofactor\n                int determinant = GetDeterminant(cofactor, n - 1);\n                // Multiplying the determinant by the sign and assigning it to adjoint[j, i]\n                adjoint[j, i] =  sign * determinant;\n            }\n        }\n        \n        // Returning the calculated adjoint matrix\n        return adjoint;\n    }\n\n    /// <summary>\n    /// Function to calculate the cofactor of a matrix element\n    /// </summary>\n    public static int[,] GetCofactor(int[,] matrix, int row, int col) {\n\n        // Getting the size of the matrix (square matrix)\n        int n = matrix.GetLength(0);\n        // Creating a 2D array to store the cofactor matrix\n        int[,] cofactor = new int[n - 1, n - 1];\n\n        int rowOffset = 0;\n        int colOffset = 0;\n\n        for(int i = 0; i < n; i++) {\n            if(i == row) {\n                // Skipping the current row by setting rowOffset to -1\n                rowOffset = -1;\n                continue;\n            }\n\n            colOffset = 0;\n\n            for(int j = 0; j < n; j++) {\n                if(j == col) {\n                    // Skipping the current column by setting colOffset to -1\n                    colOffset = -1;\n                    continue;\n                }\n\n                cofactor[i + rowOffset, j + colOffset] = matrix[i, j];\n            }\n        }\n\n        // Returning the calculated cofactor matrix\n        return cofactor;\n    }\n\n    /// <summary>\n    /// Function to calculate the determinant of a matrix\n    /// </summary>\n    public static int GetDeterminant(int[,] matrix, int size) {\n\n        if(size == 1) {\n            // The Base Case, returning the single element for a 1x1 matrix\n            return matrix[0, 0];\n        }\n\n        int determinant = 0;\n        int sign = 1;\n\n        for(int i = 0; i < size; i++) {\n            int[,] submatrix = new int[size - 1, size - 1];\n\n            for(int j = 0; j < size - 1; j++) {\n                for(int k = 0; k < size - 1; k++) {\n                    if(k < i) {\n                        // Filling the submatrix while skipping the current column \n                        submatrix[j, k] = matrix[j + 1, k];\n                    }\n                    else {\n                        // Filling the submatrix while skipping the current column\n                        submatrix[j, k] = matrix[j + 1, k + 1];\n                    }\n                }\n            }\n\n            // Calculating the determinant\n            determinant += sign * matrix[0, i] * GetDeterminant(submatrix, size - 1);\n            // Toggling the sign for the next iteration\n            sign = -sign;\n        }\n\n        // Returning the calculated determinant\n        return determinant;\n    }\n\n    /// <summary>\n    /// Function to display the matrix in the specified format\n    /// </summary>\n    public static void DisplayMatrix(int[,] matrix) {\n\n        int numRows = matrix.GetLength(0);\n        int numCols = matrix.GetLength(1);\n\n        Console.Write(\"[\");\n        for(int i = 0; i < numRows; i++) {\n            Console.Write(\"[\");\n            for(int j = 0; j < numCols; j++) {\n                Console.Write(matrix[i, j]);\n                if(j != numCols - 1) {\n                    Console.Write(\", \");\n                }\n            }\n            Console.Write(\"]\");\n            if(i != numRows - 1) {\n                Console.Write(\", \");\n            }\n        }\n        Console.Write(\"]\");\n        Console.WriteLine();\n    }\n\n    /// <summary>\n    /// Main Method\n    /// </summary>\n    public static void Main(string[] args) {\n\n        // The Original Matrix\n        int[,] matrix = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n\n        Console.WriteLine(\"Original Matrix:\");\n        DisplayMatrix(matrix);\n\n        // Calculating the adjoint matrix\n        int[,] adjoint = GetAdjoint(matrix);\n\n        Console.WriteLine(\"\\nAdjoint Matrix:\");\n        DisplayMatrix(adjoint);\n    }\n}\n",
  "java": "\npublic class Adjoints {\n\n\tstatic void getCofactors(int A[][], int temp[][], int p, int q, int n) {\n\t\tint i = 0, j = 0;\n\t\tfor (int row = 0; row < n; row++) {\n\t\t\tfor (int col = 0; col < n; col++) {\n\t\t\t\tif (row != p && col != q) {\n\t\t\t\t\ttemp[i][j++] = A[row][col];\n\t\t\t\t\tif (j == n - 1) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int determinant(int A[][], int n) {\n\n\t\tif (n == 1)\n\t\t\treturn A[0][0];\n\t\tint N = A.length;\n\t\tint[][] tableTmp = new int[N][N];\n\t\tint D = 0;\n\t\t\n\t\tint sign = 1;\n\t\tfor (int f = 0; f < n; f++) {\n\t\t\tgetCofactors(A, tableTmp, 0, f, n);\n\t\t\tD += sign * A[0][f] * determinant(tableTmp, n - 1);\n\t\t\tsign = -1 * sign;\n\t\t}\n\n\t\treturn D;\n\t}\n\n\tpublic static int[][] adjoint(int A[][]) {\n\n\t\tint N = A.length;\n\t\tint[][] adj = new int[N][N];\n\t\tif (N == 1) {\n\t\t\tadj[0][0] = 1;\n\t\t\treturn adj;\n\t\t}\n\n\t\tint sign = 1;\n\t\tint[][] temp = new int[N][N];\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tgetCofactors(A, temp, i, j, N);\n\n\t\t\t\tsign = ((i + j) % 2 == 0) ? 1 : -1;\n\n\t\t\t\tadj[j][i] = (sign) * (determinant(temp, N - 1));\n\t\t\t}\n\t\t}\n\t\treturn adj;\n\t}\n\n}",
  "javascript": "//simple function to find adj of matrix\nlet mat = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\n\nfunction adjoint(matrix) {\n  let A00 = matrix[0][0];\n  let A01 = matrix[0][1];\n  let A02 = matrix[0][2];\n  let A10 = matrix[1][0];\n  let A11 = matrix[1][1];\n  let A12 = matrix[1][2];\n  let A20 = matrix[2][0];\n  let A21 = matrix[2][1];\n  let A22 = matrix[2][2];\n\n  let adj = [\n    [A11 * A22 - A12 * A21, -(A01 * A22 - A02 * A21), A01 * A12 - A02 * A11],\n    [-(A10 * A22 - A12 * A20), A00 * A22 - A02 * A20, -(A00 * A12 - A02 * A10)],\n    [A10 * A21 - A11 * A20, -(A00 * A21 - A01 * A20), A00 * A11 - A01 * A10],\n  ];\n  return adj;\n}\n\nlet adjaointOfMatrix = adjoint(mat);\nconsole.log(adjaointOfMatrix);\n\n//adjoint of matrix using loop\n// function adjoint(matrix) {\n//     let adj = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n\n//     for (let i = 0; i < 3; i++) {\n//         for (let j = 0; j < 3; j++) {\n//             let a = (i + 1) % 3;\n//             let b = (j + 1) % 3;\n//             let c = (i + 2) % 3;\n//             let d = (j + 2) % 3;\n\n//             adj[j][i] = (matrix[a][b] * matrix[c][d] - matrix[a][d] * matrix[c][b]);\n//             if ((i + j) % 2 === 1) {\n//                 adj[j][i] = -adj[j][i];\n//             }\n//         }\n//     }\n\n//     return adj;\n// }\n",
  "kotlin": "fun main() {\n    val matrixA = listOf(\n        listOf(1, 2, 3),\n        listOf(4, 5, 6),\n        listOf(7, 8, 9)\n    )\n\n    val matrixAdjoint = calculateAdjoint(matrixA)\n\n    println(\"Input (A): $matrixA\")\n    println(\"Matrix of Adjoint (A*): $matrixAdjoint\")\n}\n\nfun calculateAdjoint(matrix: List<List<Int>>): List<List<Int>> {\n    val matrixCofactors = calculateCofactors(matrix)\n    return transpose(matrixCofactors)\n}\n\nfun calculateCofactors(matrix: List<List<Int>>): List<List<Int>> {\n    return matrix.mapIndexed { i, row ->\n        row.indices.map { j ->\n            getCofactor(matrix, i, j)\n        }\n    }\n}\n\nfun transpose(matrix: List<List<Int>>): List<List<Int>> {\n    if (matrix.isEmpty() || matrix[0].isEmpty())\n        return emptyList()\n\n    val numRows = matrix.size\n    val numCols = matrix[0].size\n\n    return List(numCols) { col ->\n        List(numRows) { row ->\n            matrix[row][col]\n        }\n    }\n}\n\nfun getCofactor(matrix: List<List<Int>>, row: Int, col: Int): Int {\n    val sign = if ((row + col) % 2 == 0) 1 else -1\n    val subMatrix = getSubMatrix(matrix, row, col)\n    return sign * determinant(subMatrix)\n}\n\nfun getSubMatrix(matrix: List<List<Int>>, rowToRemove: Int, colToRemove: Int): List<List<Int>> {\n    return matrix\n        .filterIndexed { i, _ -> i != rowToRemove }\n        .map { row -> row.filterIndexed { j, _ -> j != colToRemove } }\n}\n\nfun determinant(matrix: List<List<Int>>): Int {\n    if (matrix.size == 2)\n        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]\n\n    return matrix.indices.sumOf { i ->\n        val sign = if (i % 2 == 0) 1 else -1\n        val subMatrix = getSubMatrix(matrix, 0, i)\n        sign * matrix[0][i] * determinant(subMatrix)\n    }\n}",
  "typescript": "// Function to get cofactor of mat[p][q] in temp[][]. n is current dimension of mat[][]\n\nfunction getCofactor(mat: number[][], temp: number[][], p: number, q: number) {\n  let i = 0,\n    j = 0;\n  const n = mat.length;\n\n  // Looping for each element of the matrix\n  for (let row = 0; row < n; row++) {\n    for (let col = 0; col < n; col++) {\n      // Copying into temporary matrix only those element\n      // which are not in given row and column\n      if (row !== p && col !== q) {\n        temp[i][j++] = mat[row][col];\n\n        // Row is filled, so increase row index and\n        // reset col index\n        if (j === n - 1) {\n          j = 0;\n          i++;\n        }\n      }\n    }\n  }\n}\n\n// Recursive function for finding determinant of matrix. n is current dimension of mat[][].\n\nfunction getDeterminant(mat: number[][], n: number) {\n  // Base case : if matrix contains single element\n  if (n === 1) return mat[0][0];\n\n  let det = 0; // Initialize determinant result\n  const l = mat.length;\n  const temp: number[][] = new Array(l); // To store cofactors\n\n  for (let i = 0; i < l; i++) {\n    temp[i] = new Array(l);\n  }\n\n  let sign = 1; // To store sign multiplier\n\n  // Iterate for each element of first row\n  for (let f = 0; f < n; f++) {\n    // Getting Cofactor of mat[0][f]\n    getCofactor(mat, temp, 0, f);\n    det += sign * mat[0][f] * getDeterminant(temp, n - 1);\n\n    // terms are to be added with alternate sign\n    sign = -sign;\n  }\n\n  return det;\n}\n\n// Function to get adjoint of mat[l][l] in adj[l][l].\nfunction getAdjoint(mat: number[][]) {\n  const l = mat.length;\n  const adj: number[][] = new Array(l);\n  for (let i = 0; i < l; i++) {\n    adj[i] = new Array(l);\n  }\n\n  if (l === 1) {\n    adj[0][0] = 1;\n    return adj;\n  }\n\n  // temp is used to store cofactors of mat[][]\n  let sign = 1;\n  const temp: number[][] = new Array(l);\n\n  for (let i = 0; i < l; i++) {\n    temp[i] = new Array(l);\n  }\n\n  for (let i = 0; i < l; i++) {\n    for (let j = 0; j < l; j++) {\n      // Get cofactor of mat[i][j]\n      getCofactor(mat, temp, i, j);\n\n      // sign of adj[j][i] positive if sum of row\n      // and column indexes is even.\n      sign = (i + j) % 2 === 0 ? 1 : -1;\n\n      // Interchanging rows and columns to get the\n      // transpose of the cofactor matrix\n      adj[j][i] = sign * getDeterminant(temp, l - 1);\n    }\n  }\n\n  return adj;\n}\n\nfunction printMat(mat: number[][]) {\n  let matRepr = \"[\";\n  for (let i = 0; i < mat.length; i++) {\n    matRepr += \"\\n\\t[\";\n    for (let j = 0; j < mat[i].length; j++) {\n      matRepr += mat[i][j];\n      if (j < mat[i].length - 1) matRepr += \", \";\n      else matRepr += \"]\";\n    }\n  }\n  matRepr += \"\\n]\";\n  console.log(matRepr);\n}\n\nconst mat = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\nconsole.log(\"Original matrix:\");\nprintMat(mat);\nconsole.log(\"Adjoint matrix:\");\nprintMat(getAdjoint(mat));\n",
  "description": "\n## Write a program to find the adjoint of a matrix\n\nThe adjoint of a square matrix A is the transpose of the matrix of cofactors of A. The adjoint of a matrix A is denoted as A<sup>\\*</sup>.\n\n```txt\nInput  :\n1 2 3\n4 5 6\n7 8 9\n\nOutput :\n[[-3, 6, -3], [6, -12, 6], [-3, 6, -3]]\n```\n\n---\n",
  "trackId": 4037,
  "lastUpdated": "2024-05-15T18:39:55Z",
  "contributors": [
    "Adelechka",
    "mreza-kiani",
    "ShounaKulkarni",
    "ApurvaR1",
    "pedram-mohajer",
    "g-s-eire",
    "AshitaSingamsetty",
    "harshraj8843",
    "Ariel201711",
    "AdityaNarayanPradhan",
    "Bogumil-Sapinski-Mobica",
    "SarthakSanjay",
    "aghiles-medane",
    "joao-vitor-souza"
  ],
  "scala": "object findTheAdjointOfAMatrix {\n  def main(args: Array[String]): Unit = {\n    val matrix = Array(\n      Array(1, 2, 3),\n      Array(4, 5, 6),\n      Array(7, 8, 9)\n    )\n\n    val adjointMatrix = getAdjointMatrix(matrix)\n    println(\"Adjoint matrix:\")\n    adjointMatrix.foreach(row => println(row.mkString(\" \")))\n  }\n\n  def getAdjointMatrix(matrix: Array[Array[Int]]): Array[Array[Int]] = {\n    val n = matrix.length\n    val cofactorMatrix = Array.ofDim[Int](n, n)\n\n    for (i <- 0 until n) {\n      for (j <- 0 until n) {\n        cofactorMatrix(i)(j) = getCofactor(matrix, i, j)\n      }\n    }\n\n    transpose(cofactorMatrix)\n  }\n\n  def getCofactor(matrix: Array[Array[Int]], p: Int, q: Int): Int = {\n    val subMatrix = Array.ofDim[Int](matrix.length - 1, matrix.length - 1)\n    var row = 0\n    var col = 0\n\n    for (i <- matrix.indices) {\n      if (i != p) {\n        col = 0\n        for (j <- matrix.indices) {\n          if (j != q) {\n            subMatrix(row)(col) = matrix(i)(j)\n            col += 1\n          }\n        }\n        row += 1\n      }\n    }\n\n    val sign = if ((p + q) % 2 == 0) 1 else -1\n    sign * determinant(subMatrix)\n  }\n\n  def determinant(matrix: Array[Array[Int]]): Int = {\n    if (matrix.length == 1) {\n      return matrix(0)(0)\n    }\n    if (matrix.length == 2) {\n      return matrix(0)(0) * matrix(1)(1) - matrix(0)(1) * matrix(1)(0)\n    }\n\n    var det = 0\n    for (i <- matrix.indices) {\n      val subMatrix = Array.ofDim[Int](matrix.length - 1, matrix.length - 1)\n      for (j <- 1 until matrix.length) {\n        var colIndex = 0\n        for (k <- matrix.indices) {\n          if (k != i) {\n            subMatrix(j - 1)(colIndex) = matrix(j)(k)\n            colIndex += 1\n          }\n        }\n      }\n      det += matrix(0)(i) * determinant(subMatrix) * (if (i % 2 == 0) 1 else -1)\n    }\n\n    det\n  }\n\n  def transpose(matrix: Array[Array[Int]]): Array[Array[Int]] = {\n    val n = matrix.length\n    val transposedMatrix = Array.ofDim[Int](n, n)\n\n    for (i <- 0 until n) {\n      for (j <- 0 until n) {\n        transposedMatrix(j)(i) = matrix(i)(j)\n      }\n    }\n\n    transposedMatrix\n  }\n}\n",
  "go": "package main\n\nimport \"fmt\"\n\nfunc getCofactor(matrix [][]int, temp [][]int, p, q, n int) {\n\tvar i, j int\n\tfor row := 0; row < n; row++ {\n\t\tfor col := 0; col < n; col++ {\n\t\t\tif row != p && col != q {\n\t\t\t\ttemp[i][j], j = matrix[row][col], j+1\n\t\t\t\tif j == n-1 {\n\t\t\t\t\tj = 0\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nfunc determinant(matrix [][]int, n int) int {\n\tif n == 1 {\n\treturn matrix[0][0]\n\t}\n\tvar D, sign int = 0, 1\n\ttemp := make([][]int, len(matrix))\n\tfor i := range temp {\n\t\ttemp[i] = make([]int, len(matrix))\n\t}\n\tfor f := 0; f < n; f++ {\n\t\tgetCofactor(matrix, temp, 0, f, n)\n\t\tD += sign * matrix[0][f] * determinant(temp, n-1)\n\t\tsign = -sign\n\t}\n\treturn D\n}\nfunc adjoint(matrix [][]int) [][]int {\n\tn := len(matrix)\n\tadj := make([][]int, n)\n\tfor i := range adj {\n\t\tadj[i] = make([]int, n)\n\t}\n\ttemp := make([][]int, n)\n\tfor i := range temp {\n\t\ttemp[i] = make([]int, n)\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tgetCofactor(matrix, temp, i, j, n)\n\t\t\tsign := 1\n\t\t\tif (i+j)%2 != 0 {\n\t\t\t\tsign = -1\n\t\t\t}\n\t\t\tadj[j][i] = sign * determinant(temp, n-1)\n\t\t}\n\t}\n\treturn adj\n}\nfunc main() {\n\tmatrix := [][]int{\n\t\t{1, 2, 3},\n\t\t{4, 5, 6},\n\t\t{7, 8, 9},\n\t}\n\tadj := adjoint(matrix)\n\tfmt.Println(\"Output :\")\n\tfor _, row := range adj {\n\t\tfmt.Println(row)\n\t}\n}",
  "php": "<?php\n// Function to calculate the determinant of a matrix\nfunction determinant(array $matrix, $size) {\n    $det = 0;\n    if ($size == 1) {\n        return $matrix[0][0];\n    }\n\n    $temp = array_fill(0, $size, array_fill(0, $size, 0));\n    $sign = 1;\n\n    for ($f = 0; $f < $size; $f++) {\n        getCofactor($matrix, $temp, 0, $f, $size);\n        $det += $sign * $matrix[0][$f] * determinant($temp, $size - 1);\n        $sign = -$sign;\n    }\n\n    return $det;\n}\n\n// Function to get cofactor of a matrix\nfunction getCofactor(array $matrix, array &$temp, $p, $q, $n) {\n    $i = 0;\n    $j = 0;\n\n    for ($row = 0; $row < $n; $row++) {\n        for ($col = 0; $col < $n; $col++) {\n            if ($row != $p && $col != $q) {\n                $temp[$i][$j++] = $matrix[$row][$col];\n                if ($j == $n - 1) {\n                    $j = 0;\n                    $i++;\n                }\n            }\n        }\n    }\n}\n\n// Function to calculate adjoint of a matrix\nfunction adjoint(array &$matrix) {\n    $size = count($matrix);\n    if ($size == 1) {\n        $matrix[0][0] = 1;\n        return;\n    }\n\n    $sign = 1;\n    $temp = array_fill(0, $size, array_fill(0, $size, 0));\n\n    $adj = array_fill(0, $size, array_fill(0, $size, 0));\n    for ($i = 0; $i < $size; $i++) {\n        for ($j = 0; $j < $size; $j++) {\n            getCofactor($matrix, $temp, $i, $j, $size);\n            $sign = (($i + $j) % 2 == 0) ? 1 : -1;\n            $adj[$j][$i] = ($sign) * (determinant($temp, $size - 1));\n        }\n    }\n    $matrix = $adj;\n}\n\n// Taking input from the user\necho \"Enter the size of the matrix (n for n*n matrix): \";\n$size = trim(fgets(STDIN));\n\n$matrix = array();\necho \"Enter the elements of the matrix row by row:\\n\";\nfor ($i = 0; $i < $size; $i++) {\n    $matrix[$i] = explode(\" \", trim(fgets(STDIN)));\n}\n\nadjoint($matrix);\n\necho \"Adjoint of the matrix is:\\n\";\nforeach ($matrix as $row) {\n    echo \"[\" . implode(\", \", $row) . \"]\\n\";\n}\n?>\n",
  "python": "from typing import List\nimport numpy as np\n\n\ndef compute_adjoint_matrix(matrix: List[List[int]]) -> np.ndarray:\n    n_lines = len(matrix)\n    n_columns = len(matrix[0])\n    cofactor_matrix = np.array([])\n    if n_lines != n_columns:\n        print(\"Input a square matrix!\")\n        return\n    for line in range(n_lines):\n        for column in range(n_columns):\n            minor_matrix = []\n            for minor_line in matrix:\n                minor_line_copy = minor_line.copy()\n                minor_line_copy.pop(column)\n                minor_matrix.append(minor_line_copy)\n            minor_matrix.pop(line)\n            cofactor_matrix = np.append(\n                cofactor_matrix, (-1) ** (line + column) * np.linalg.det(minor_matrix)\n            )\n\n    return cofactor_matrix.reshape((n_lines, n_columns)).T\n\n\nprint(compute_adjoint_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n\n\"\"\" Output:\n[[ -3.   6.  -3.]\n [  6. -12.   6.]\n [ -3.   6.  -3.]]\n\"\"\"\n",
  "r": "# Function to calculate the cofactor of an element in a matrix\ncofactor <- function(mat, row, col) {\n  sub_mat <- mat[-row, -col] # Remove the row and column\n  return ((-1)^(row + col) * det(sub_mat))\n}\n\n# Function to calculate the cofactor matrix\ncofactorMatrix <- function(mat) {\n  n <- nrow(mat)\n  cofactor_mat <- matrix(0, n, n)\n  for (i in 1:n) {\n    for (j in 1:n) {\n      cofactor_mat[i, j] <- cofactor(mat, i, j)\n    }\n  }\n  return (cofactor_mat)\n}\n\n# Function to find the adjoint of a matrix\nfindAdjoint <- function(mat) {\n  return (t(cofactorMatrix(mat))) # Transpose of the cofactor matrix\n}\n\n# Test the function with the input matrix\ninput_matrix <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, byrow = TRUE)\nadjoint_matrix <- findAdjoint(input_matrix)\nprint(adjoint_matrix)\n",
  "rust": "fn main() {\n    // Define the input matrix\n    let matrix: [[i32; 3]; 3] = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9],\n    ];\n\n    // Calculate and print the adjoint of the matrix\n    let adjoint_matrix = adjoint(&matrix);\n    print_adjoint_matrix(&adjoint_matrix);\n}\n\nfn adjoint(matrix: &[[i32; 3]; 3]) -> [[i32; 3]; 3] {\n    let mut adjoint_matrix: [[i32; 3]; 3] = [[0; 3]; 3];\n\n    for i in 0..3 {\n        for j in 0..3 {\n            // Calculate the cofactor for each element\n            let cofactor_value = cofactor(matrix, i, j);\n\n            // Transpose the cofactor matrix to get the adjoint matrix\n            adjoint_matrix[j][i] = cofactor_value;\n        }\n    }\n\n    adjoint_matrix\n}\n\nfn cofactor(matrix: &[[i32; 3]; 3], row: usize, col: usize) -> i32 {\n    // Calculate the minor matrix by excluding the current row and column\n    let mut minor_matrix: [[i32; 2]; 2] = [[0; 2]; 2];\n    let mut minor_row = 0;\n    for i in 0..3 {\n        if i == row {\n            continue;\n        }\n        let mut minor_col = 0;\n        for j in 0..3 {\n            if j == col {\n                continue;\n            }\n            minor_matrix[minor_row][minor_col] = matrix[i][j];\n            minor_col += 1;\n        }\n        minor_row += 1;\n    }\n\n    // Calculate the determinant of the minor matrix\n    let minor_det = (minor_matrix[0][0] * minor_matrix[1][1]) - (minor_matrix[0][1] * minor_matrix[1][0]);\n\n    // Apply the sign based on the position of the element in the matrix\n    let sign = if (row + col) % 2 == 0 { 1 } else { -1 };\n\n    // Multiply the determinant by the sign to get the cofactor\n    sign * minor_det\n}\n\nfn print_adjoint_matrix(matrix: &[[i32; 3]; 3]) {\n    print!(\"[\");\n    for row in matrix.iter().take(matrix.len() - 1) {\n        print!(\"{}, \", format_row(row));\n    }\n    print!(\"{}]\", format_row(matrix.last().unwrap()));\n}\n\nfn format_row(row: &[i32; 3]) -> String {\n    format!(\"[{}]\", row.iter().map(|&x| x.to_string()).collect::<Vec<_>>().join(\", \"))\n}\n",
  "languages": [
    "c",
    "c-plus-plus",
    "c-sharp",
    "java",
    "javascript",
    "kotlin",
    "typescript",
    "scala",
    "go",
    "php",
    "python",
    "r",
    "rust"
  ]
}