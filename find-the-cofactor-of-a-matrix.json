{
  "slug": "find-the-cofactor-of-a-matrix",
  "title": "Find The Cofactor Of A Matrix",
  "c": "#include <stdio.h>\n\nint findMinorAndSign(int matrix[3][3], int row, int col)\n{\n    int detM[4], p = 0;\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            if (i != row && j != col)\n            {\n                detM[p++] = matrix[i][j];\n            }\n        }\n    }\n\n    int detValue = detM[0] * detM[3] - detM[1] * detM[2];\n\n    if ((row + col) % 2 == 1)\n    {\n        detValue *= -1;\n    }\n\n    return detValue;\n}\n\nvoid printMatrix(int matrix[3][3])\n{\n    printf(\"[\");\n    for (int i = 0; i < 3; i++)\n    {\n        printf(\"[\");\n        for (int j = 0; j < 3; j++)\n        {\n            printf(\"%d\", matrix[i][j]);\n            if (j != 2)\n            {\n                printf(\", \");\n            }\n        }\n        printf(\"]\");\n        if (i != 2)\n        {\n            printf(\", \");\n        }\n    }\n\n    printf(\"]\\n\");\n}\n\nvoid coFactorMatrix(int input[3][3], int output[3][3])\n{\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            output[i][j] = findMinorAndSign(input, i, j);\n        }\n    }\n}\n\nint main()\n{\n    int input[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n\n    int coFactors[3][3];\n    coFactorMatrix(input, coFactors);\n\n    printMatrix(coFactors);\n}",
  "c-plus-plus": "#include <iostream>\n\n\n// Matrix Class\nclass Matrix {\npublic:\n    /*\n    Arguments: numRows, numColumns, array pointer\n    Returns: a Matrix with the specified rows and columns,\n        with each element filled according to appearance in array pointer\n    Example:\n        - 2, 2, arrPtr\n        - arrPtr points to int array with values [1, 2, 3, 4]\n    */\n    Matrix(int numRows, int numColumns, int* arrPtr) {\n        int** matrix = new int* [numRows];\n        this->numRows = numRows;\n        this->numColumns = numColumns;\n\n        for (int i = 0; i < numRows; i++) {\n            matrix[i] = new int[numColumns];\n\n            for (int j = 0; j < numColumns; j++) {\n                matrix[i][j] = *arrPtr;\n                arrPtr += 1;\n            }\n        }\n        this->matrix = matrix;\n    }\n\n    /*\n    Function: The copy constructor for the Matrix Class\n    Arguments: a Matrix\n    Returns: an identical Matrix as a deep copy\n    Example: Matrix B = A, or Matrix B(A)\n    */\n    Matrix(const Matrix& rhs) {\n        int** matrix = new int* [rhs.numRows];\n        this->numRows = rhs.numRows;\n        this->numColumns = rhs.numColumns;\n\n        for (int i = 0; i < rhs.numRows; i++) {\n            matrix[i] = new int[rhs.numColumns];\n\n            for (int j = 0; j < rhs.numColumns; j++) {\n                matrix[i][j] = rhs.matrix[i][j];\n            }\n        }\n        this->matrix = matrix;\n    }\n\n    /*\n    Function: destructor for the Matrix Class\n    */\n    ~Matrix() {\n        for (int i = 0; i < numRows; i++) {\n            delete[] matrix[i];\n            matrix[i] = NULL;\n        }\n        matrix = NULL;\n    }\n\n    /*\n    Function: Overloads [] operator to access rows in Matrix\n    Arguments: A row index to be accessed\n    Returns: the pointer from that row index (this row is a list of values)\n    Example: A[0]\n    */\n    int* operator [] (int rowIdx) {\n        int* rowPtr = this->matrix[rowIdx];\n        return rowPtr;\n    }\n\nprivate:\n    int** matrix;\n    int numRows;\n    int numColumns;\n};\n\n\n// function prototypes\nint minorAndSign(Matrix, int, int);\nvoid printMatrix(Matrix, int, int);\n\n\n// main\nint main()\n{\n    // create a 3x3 matrix\n    int rows = 3;\n    int columns = 3;\n    int matrixVal[rows*columns] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int* matrixValPtr = matrixVal;\n    const Matrix matrix = Matrix(rows, columns, matrixValPtr);\n    \n    // create cofactor matrix\n    int empty[rows*columns] = {};\n    int* emptyPtr = empty;\n    Matrix coFacMatrix = Matrix(rows, columns, emptyPtr);\n\n    // edit cofactor matrix\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++)\n        {\n            int minor = minorAndSign(matrix, i, j);\n            coFacMatrix[i][j] = minor;\n        }\n    }\n    // print matrix\n    printMatrix(coFacMatrix, rows, columns);\n\n    // assign remaining pointers to NULL\n    matrixValPtr = NULL;\n    emptyPtr = NULL;\n\n    return 0;\n}\n\n\nint minorAndSign(Matrix matrix, int row, int column) {\n    int detNums[4];\n    int detNumsIdx = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if ((i != row) && (j != column)) {\n                detNums[detNumsIdx] = matrix[i][j];\n                detNumsIdx += 1;\n            }\n        }\n    }\n\n    // If row + column are odd, multiply by -1\n    if ((row+column) % 2 != 0) {\n        return (-1)*(detNums[0]*detNums[3] - detNums[1]*detNums[2]);\n    }\n    return (detNums[0]*detNums[3] - detNums[1]*detNums[2]);\n}\n\n\n// Prints each element of the matrix\nvoid printMatrix(Matrix matrix, int row, int col) {\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            if (j != (col-1)) {\n                std::cout << matrix[i][j] << ' ';\n            }\n            else {\n                std::cout << matrix[i][j] << std::endl;\n            }\n        }\n    }\n}\n",
  "c-sharp": "ï»¿using System;\r\n\r\nclass Program\r\n{\r\n    static void Main()\r\n    {\r\n        // Define the sample matrix (3x3)\r\n        int[,] matrix = {\r\n            {1, 2, 3},\r\n            {4, 5, 6},\r\n            {7, 8, 9}\r\n        };\r\n\r\n        Console.WriteLine(\"Original Matrix:\");\r\n        PrintMatrix(matrix);\r\n\r\n        Console.WriteLine(\"\\nCofactor of the Matrix:\");\r\n        int[,] cofactorMatrix = CalculateCofactor(matrix);\r\n        PrintMatrix(cofactorMatrix);\r\n    }\r\n\r\n    static void PrintMatrix(int[,] matrix)\r\n    {\r\n        int rows = matrix.GetLength(0);\r\n        int columns = matrix.GetLength(1);\r\n\r\n        for (int i = 0; i < rows; i++)\r\n        {\r\n            for (int j = 0; j < columns; j++)\r\n            {\r\n                Console.Write(matrix[i, j] + \"\\t\");\r\n            }\r\n            Console.WriteLine();\r\n        }\r\n    }\r\n\r\n    static int[,] CalculateCofactor(int[,] matrix)\r\n    {\r\n        int rows = matrix.GetLength(0);\r\n        int columns = matrix.GetLength(1);\r\n\r\n        int[,] cofactorMatrix = new int[rows, columns];\r\n\r\n        for (int i = 0; i < rows; i++)\r\n        {\r\n            for (int j = 0; j < columns; j++)\r\n            {\r\n                cofactorMatrix[i, j] = CalculateCofactorElement(matrix, i, j) * (int)Math.Pow(-1, i + j);\r\n            }\r\n        }\r\n\r\n        return cofactorMatrix;\r\n    }\r\n\r\n    static int CalculateCofactorElement(int[,] matrix, int row, int column)\r\n    {\r\n        int rows = matrix.GetLength(0);\r\n        int columns = matrix.GetLength(1);\r\n\r\n        int[,] submatrix = new int[rows - 1, columns - 1];\r\n\r\n        int destRow = 0;\r\n        for (int i = 0; i < rows; i++)\r\n        {\r\n            if (i == row)\r\n                continue;\r\n\r\n            int destColumn = 0;\r\n            for (int j = 0; j < columns; j++)\r\n            {\r\n                if (j == column)\r\n                    continue;\r\n\r\n                submatrix[destRow, destColumn] = matrix[i, j];\r\n                destColumn++;\r\n            }\r\n\r\n            destRow++;\r\n        }\r\n\r\n        return Determinant(submatrix);\r\n    }\r\n\r\n    static int Determinant(int[,] matrix)\r\n    {\r\n        int rows = matrix.GetLength(0);\r\n        int columns = matrix.GetLength(1);\r\n\r\n        if (rows != columns)\r\n            throw new ArgumentException(\"The matrix is not square.\");\r\n\r\n        if (rows == 2)\r\n        {\r\n            return matrix[0, 0] * matrix[1, 1] - matrix[0, 1] * matrix[1, 0];\r\n        }\r\n\r\n        int determinant = 0;\r\n        for (int j = 0; j < columns; j++)\r\n        {\r\n            determinant += matrix[0, j] * CalculateCofactorElement(matrix, 0, j) * (int)Math.Pow(-1, 0 + j);\r\n        }\r\n\r\n        return determinant;\r\n    }\r\n}\r\n",
  "javascript": "// List of Functions:\n\n// returns the minor for every element in matrix\n// and applies cofactor sign to minor\nfunction minorAndSign(matrix, row, column) {\n  const detNums = [];\n  let detNumIdx = 0;\n  for (let i = 0; i < 3; i++) {\n    for (let j = 0; j < 3; j++) {\n      if (i != row && j != column) {\n        detNums[detNumIdx] = matrix[i][j];\n        detNumIdx += 1;\n      }\n    }\n  }\n  // apply cofactor sign\n  // if row+column is odd, multiply number by -1\n  if ((row + column) % 2 != 0) {\n    return detNums[1] * detNums[2] - detNums[0] * detNums[3];\n  }\n  return detNums[0] * detNums[3] - detNums[1] * detNums[2];\n}\n\n// print matrix\nfunction printMatrix(matrix) {\n  for (let row = 0; row < 3; row++) {\n    console.log(matrix[row]);\n  }\n}\n\n// Main:\n// Get cofactor matrix of 3x3 matrix\n// No html file, so set matrix values here\nconst matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\n\n// For each element:\n//  get minor\n// add to coFacMatrix\nconst coFacMatrix = [[], [], []];\n\nfor (let i = 0; i < 3; i++) {\n  for (let j = 0; j < 3; j++) {\n    let minor = minorAndSign(matrix, i, j);\n    coFacMatrix[i][j] = minor;\n  }\n}\nprintMatrix(coFacMatrix);\n",
  "swift": "import Foundation\n\nclass Matrix {\n    let rows: Int\n    let columns: Int\n    var grid: [[Double]]\n\n    init(rows: Int, columns: Int) {\n        self.rows = rows\n        self.columns = columns\n        self.grid = [[Double]](repeating: [Double](repeating: 0.0, count: columns), count: rows)\n    }\n\n    init(grid: [[Double]]) {\n        self.rows = grid.count\n        self.columns = grid[0].count\n        self.grid = grid\n    }\n\n    func printMatrix() {\n        for i in 0..<rows {\n            print(grid[i])\n        }\n    }\n\n    func minorMatrix(row: Int, column: Int) -> Matrix {\n        var minor = [[Double]]()\n\n        for i in 0..<rows {\n            if i != row {\n                var minorRow = [Double]()\n                for j in 0..<columns {\n                    if j != column {\n                        minorRow.append(grid[i][j])\n                    }\n                }\n                minor.append(minorRow)\n            }\n        }\n\n        return Matrix(grid: minor)\n    }\n\n    func determinant() -> Double {\n        guard rows == columns else {\n            fatalError(\"Matrix must be square to calculate determinant\")\n        }\n\n        if rows == 1 {\n            return grid[0][0]\n        }\n\n        if rows == 2 {\n            return grid[0][0] * grid[1][1] - grid[0][1] * grid[1][0]\n        }\n\n        var det = 0.0\n        for i in 0..<columns {\n            let minorMatrix = self.minorMatrix(row: 0, column: i)\n            det += grid[0][i] * pow(-1.0, Double(i)) * minorMatrix.determinant()\n        }\n        return det\n    }\n\n    func cofactorMatrix() -> Matrix? {\n        guard rows == columns else {\n            print(\"Error: Cofactor matrix can only be calculated for square matrices\")\n            return nil\n        }\n\n        var cofactor = [[Double]]()\n        for i in 0..<rows {\n            var cofactorRow = [Double]()\n            for j in 0..<columns {\n                let minorDet = minorMatrix(row: i, column: j).determinant()\n                cofactorRow.append(pow(-1.0, Double(i + j)) * minorDet)\n            }\n            cofactor.append(cofactorRow)\n        }\n\n        return Matrix(grid: cofactor)\n    }\n}\n\nlet inputMatrix = Matrix(grid: [[1.0, 2.0, 3.0],\n                                [4.0, 5.0, 6.0],\n                                [7.0, 8.0, 9.0]])\n\nif let cofactorMatrix = inputMatrix.cofactorMatrix() {\n    print(\"Cofactor Matrix:\")\n    cofactorMatrix.printMatrix()\n}\n",
  "typescript": "function minorAndSign(matrix: number[], row: number, column: number) {\n  const detNums = [];\n  let detNumIdx: number = 0;\n  for (let i: number = 0; i < 3; i++) {\n    for (let j: number = 0; j < 3; j++) {\n      if (i != row && j != column) {\n        detNums[detNumIdx] = matrix[i][j];\n        detNumIdx += 1;\n      }\n    }\n  }\n\n  if ((row + column) % 2 != 0) {\n    return detNums[1] * detNums[2] - detNums[0] * detNums[3];\n  }\n  return detNums[0] * detNums[3] - detNums[1] * detNums[2];\n}\n\nfunction printMatrix(matrix) {\n  for (let row: number = 0; row < 3; row++) {\n    console.log(matrix[row]);\n  }\n}\n\nconst matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\n\nconst coFacMatrix = [[], [], []];\n\nfor (let i: number = 0; i < 3; i++) {\n  for (let j: number = 0; j < 3; j++) {\n    const minor: number = minorAndSign(matrix, i, j);\n    coFacMatrix[i][j] = minor;\n  }\n}\nprintMatrix(coFacMatrix);\n",
  "description": "\n## Write a program to find the cofactor of a matrix\n\nThe cofactor of an element a<sub>ij</sub> of a square matrix A is the determinant of the minor of A obtained by deleting the ith row and jth column of A. The cofactor of a matrix A is the matrix of cofactors of A.\n\n```txt\nInput  :\n1 2 3\n4 5 6\n7 8 9\n\nOutput :\n[[-3, 6, -3], [6, -12, 6], [-3, 6, -3]]\n```\n\n---\n",
  "trackId": 2344,
  "lastUpdated": "2024-06-16T13:55:26Z",
  "contributors": [
    "harshraj8843",
    "BatinSimsek",
    "Adelechka",
    "David-FR",
    "AMiracle-creator",
    "miguelangel31",
    "AdityaNarayanPradhan",
    "JoshuaT35",
    "anandfresh",
    "joao-vitor-souza",
    "PoweredByCaffein",
    "alfa-m"
  ],
  "scala": "object MatrixCofactor {\n  def main(args: Array[String]): Unit = {\n    val matrix = Array(\n      Array(3, 0, 2),\n      Array(2, 0, -2),\n      Array(0, 1, 1)\n    )\n\n    val cofactorMatrix = getCofactorMatrix(matrix)\n    println(\"Cofactor matrix:\")\n    cofactorMatrix.foreach(row => println(row.mkString(\" \")))\n  }\n\n  def getCofactorMatrix(matrix: Array[Array[Int]]): Array[Array[Int]] = {\n    val n = matrix.length\n    val cofactorMatrix = Array.ofDim[Int](n, n)\n\n    for (i <- 0 until n) {\n      for (j <- 0 until n) {\n        cofactorMatrix(i)(j) = getCofactor(matrix, i, j)\n      }\n    }\n\n    cofactorMatrix\n  }\n\n  def getCofactor(matrix: Array[Array[Int]], p: Int, q: Int): Int = {\n    val subMatrix = Array.ofDim[Int](matrix.length - 1, matrix.length - 1)\n    var row = 0\n    var col = 0\n\n    for (i <- matrix.indices) {\n      if (i != p) {\n        col = 0\n        for (j <- matrix.indices) {\n          if (j != q) {\n            subMatrix(row)(col) = matrix(i)(j)\n            col += 1\n          }\n        }\n        row += 1\n      }\n    }\n\n    val sign = if ((p + q) % 2 == 0) 1 else -1\n    sign * determinant(subMatrix)\n  }\n\n  def determinant(matrix: Array[Array[Int]]): Int = {\n    if (matrix.length == 1) {\n      return matrix(0)(0)\n    }\n    if (matrix.length == 2) {\n      return matrix(0)(0) * matrix(1)(1) - matrix(0)(1) * matrix(1)(0)\n    }\n\n    var det = 0\n    for (i <- matrix.indices) {\n      val subMatrix = Array.ofDim[Int](matrix.length - 1, matrix.length - 1)\n      for (j <- 1 until matrix.length) {\n        var colIndex = 0\n        for (k <- matrix.indices) {\n          if (k != i) {\n            subMatrix(j - 1)(colIndex) = matrix(j)(k)\n            colIndex += 1\n          }\n        }\n      }\n      det += matrix(0)(i) * determinant(subMatrix) * (if (i % 2 == 0) 1 else -1)\n    }\n\n    det\n  }\n}\n",
  "go": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tfmt.Println(\"Co-factor of a Matrix\")\n\tfmt.Printf(\"Enter elements of the matrix, separated by space: \")\n\tvar matrix, result [3][3]int\n\tfor i := 0; i < 3; i++ {\n\t\tfor j := 0; j < 3; j++ {\n\t\t\tfmt.Scanf(\"%d\", &matrix[i][j])\n\t\t}\n\t}\n\n\tfmt.Println(\"Input matrix:\")\n\tprettyPrintMatrix(matrix)\n\n\tfor i := 0; i < 3; i++ {\n\t\tfor j := 0; j < 3; j++ {\n\t\t\tresult[i][j] = findDet(i, j, matrix)\n\t\t}\n\t}\n\n\tfmt.Println(\"Co-factor of matrix:\")\n\tprettyPrintMatrix(result)\n}\n\nfunc findDet(row, col int, matrix [3][3]int) int {\n\tvar elements []int\n\tfor i := 0; i < 3; i++ {\n\t\tfor j := 0; j < 3; j++ {\n\t\t\tif !(i == row || j == col) {\n\t\t\t\telements = append(elements, matrix[i][j])\n\t\t\t}\n\t\t}\n\t}\n\n\tdet := int(math.Pow(-1, float64(row+col))) * ((elements[0] * elements[3]) - (elements[1] * elements[2]))\n\n\treturn det\n}\n\nfunc prettyPrintMatrix(matrix [3][3]int) {\n\tfor i := 0; i < 3; i++ {\n\t\tfor j := 0; j < 3; j++ {\n\t\t\tfmt.Printf(\"%v\\t\", matrix[i][j])\n\t\t}\n\t\tfmt.Println()\n\t}\n}\n",
  "php": "<?php\r\n\r\nfunction getCofactor($matrix, $p, $q) {\r\n    $temp = [];\r\n    $n = count($matrix);\r\n    $i = 0;\r\n    $j = 0;\r\n\r\n    for ($row = 0; $row < $n; $row++) {\r\n        for ($col = 0; $col < $n; $col++) {\r\n            if ($row != $p && $col != $q) {\r\n                $temp[$i][$j++] = $matrix[$row][$col];\r\n                if ($j == $n - 1) {\r\n                    $j = 0;\r\n                    $i++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return $temp;\r\n}\r\n\r\nfunction determinant($matrix, $n) {\r\n    if ($n == 1) {\r\n        return $matrix[0][0];\r\n    }\r\n    $temp = [];\r\n    $sign = 1;\r\n    $d = 0;\r\n\r\n    for ($f = 0; $f < $n; $f++) {\r\n        $temp = getCofactor($matrix, 0, $f);\r\n        $d += $sign * $matrix[0][$f] * determinant($temp, $n - 1);\r\n        $sign = -$sign;\r\n    }\r\n    return $d;\r\n}\r\n\r\nfunction cofactor($matrix) {\r\n    $n = count($matrix);\r\n    $cofactorMatrix = [];\r\n\r\n    for ($i = 0; $i < $n; $i++) {\r\n        for ($j = 0; $j < $n; $j++) {\r\n            $temp = getCofactor($matrix, $i, $j);\r\n            $cofactorMatrix[$i][$j] = determinant($temp, $n - 1) * pow(-1, $i + $j);\r\n        }\r\n    }\r\n    return $cofactorMatrix;\r\n}\r\n\r\n$matrix = [\r\n    [1, 2, 3],\r\n    [4, 5, 6],\r\n    [7, 8, 9]\r\n];\r\n\r\n$cofactorMatrix = cofactor($matrix);\r\nforeach ($cofactorMatrix as $row) {\r\n    echo \"[\" . implode(\", \", $row) . \"]\\n\";\r\n}\r\n\r\n",
  "python": "from typing import List\n\nimport numpy as np\n\n\ndef compute_cofactor_matrix(matrix: List[List[int]]) -> np.ndarray:\n    n_lines = len(matrix)\n    n_columns = len(matrix[0])\n    cofactor_matrix = np.array([])\n    if n_lines != n_columns:\n        print(\"Input a square matrix!\")\n        return\n    for line in range(n_lines):\n        for column in range(n_columns):\n            minor_matrix = []\n            for minor_line in matrix:\n                minor_line_copy = minor_line.copy()\n                minor_line_copy.pop(column)\n                minor_matrix.append(minor_line_copy)\n            minor_matrix.pop(line)\n            cofactor_matrix = np.append(\n                cofactor_matrix, (-1) ** (line + column) * np.linalg.det(minor_matrix)\n            )\n\n    return cofactor_matrix.reshape((n_lines, n_columns))\n\n\nprint(compute_cofactor_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n\n\"\"\" Output:\n[[ -3.   6.  -3.]\n [  6. -12.   6.]\n [ -3.   6.  -3.]]\n\"\"\"\n",
  "r": "# Clear the environment\nrm(list = ls())\n\n# Function that calculates the cofactors\ncalculate_cofactor <- function(original_matrix, matrix_order){\n  print(\"Original matrix:\")\n  print(original_matrix)\n  \n  cofactor_matrix <- matrix(, nrow = matrix_order, ncol = matrix_order)\n  \n  for (column in 1:matrix_order) {\n    matrix_minus_column <- your_matrix[,-column]\n    for (row in 1:matrix_order) {\n      if (matrix_order == 2) {\n        matrix_minus_row <- matrix_minus_column[-row]\n        cofactor_matrix[row, column] <- ((-1)^(row + column))*matrix_minus_row\n      } else {\n        matrix_minus_row <- matrix_minus_column[-row,]\n        cofactor_matrix[row, column] <- ((-1)^(row + column))*det(matrix_minus_row)\n      }\n    }\n  }\n  \n  return(cofactor_matrix)\n}\n\n# Request the matrix\nmatrix_ord <- as.integer(readline(\"What is the order of your matrix?: \"))\nmessage(cat(\"Enter the \", matrix_ord^2, \" values of your matrix:\"))\nmatrix_content <- c(scan(nmax = (matrix_ord^2)))\nyour_matrix <- matrix(data = matrix_content, nrow = matrix_ord, byrow = TRUE)\n\n# Shows the calculated cofactors\ncofactor <- calculate_cofactor(your_matrix, matrix_ord)\nprint(\"Matrix of cofactors:\")\nprint(cofactor)\n",
  "languages": [
    "c",
    "c-plus-plus",
    "c-sharp",
    "javascript",
    "swift",
    "typescript",
    "scala",
    "go",
    "php",
    "python",
    "r"
  ]
}